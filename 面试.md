# 自我介绍

## 通用版

面试官您好，我叫xxx，是湖南师范大学软件工程专业的本科应届生，在校期间，我系统地学习了软件开发的相关课程，掌握了扎实的编程基础和软件开发技能，并且通过多个项目实践，积累了一定的实际开发经验。此外，我在企业实习过3个月，实习期间主要是负责原有系统的维护和增强，如为网关加入应用防火墙，搭建监控服务等，还参与了新系统部分模块的开发工作。很高兴能获得这次面试的机会，非常期待能有机会在贵公司这样专业的平台上深入发展和学习，以上就是我的自我介绍，谢谢。

# 常见问题

## 数据库

### ACID特性

事务是数据库管理系统中一组操作的集合，这些操作要么全部成功，要么全部失败。

ACID是数据库事务的四个核心特性，用于保证即使在异常情况下，数据库操作也能正确可靠。

A - 原子性 (Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部发生，要么全部不发生。如果中途出错，会回滚到事务开始前的状态。（核心：全部成功 or 全部失败）

C - 一致性 (Consistency)：事务执行前后，数据库必须从一个一致性状态变换到另一个一致性状态。比如转账前后，双方的总金额必须保持一致。（核心：数据符合现实逻辑）

I - 隔离性 (Isolation)：多个并发事务执行时，一个事务的操作不应影响其他事务。数据库通过隔离级别来控制。（核心：并发事务互不干扰）

D - 持久性 (Durability)：一旦事务提交，它对数据库的修改就是永久性的，即使系统故障也不会丢失。（核心：提交即永久）

持久性：redo-log
原子性、一致性：undo-log
隔离性：锁机制、MVCC

### 事务隔离级别

并发事务问题：
    脏读：一个事务读取了另一个事务未提交的数据修改。
    不可重复读：一个事务在两次读取同一数据时，另一个事务修改了该数据，导致两次读取结果不同。
    幻读：一个事务在两次查询时，另一个事务插入了新的数据，导致第一次查询结果中没有，而第二次查询结果中有。

读未提交 (Read Uncommitted)：一个事务能读到另一个事务未提交的修改。这会导致脏读、不可重复读和幻读。（性能最高，数据最不安全）

读已提交 (Read Committed)：一个事务只能读到另一个事务已提交的修改。这是大多数数据库的默认级别（如Oracle）。它解决了脏读，但仍可能存在不可重复读和幻读。

可重复读 (Repeatable Read)：保证在同一个事务中，多次读取同一数据的结果是一致的。它解决了脏读和不可重复读，但MySQL的InnoDB引擎通过Next-Key Lock机制在此级别下也解决了幻读问题。（MySQL的默认级别）

串行化 (Serializable)：所有事务逐个顺序执行，完全隔离。能避免所有并发问题，但性能最低，类似于单线程。（数据最安全，性能最差）

### 索引失效

1. 违反最左前缀原则
2. 在索引列上使用函数或表达式
3. 模糊查询时，通配符%出现在开头
4. 隐式类型转换，如字符串未加引号
5. 使用OR连接多个条件，且其中一个条件未使用索引

### 主从同步

主从同步是指在数据库系统中，将数据从主数据库（Master）复制到一个或多个从数据库（Slave）的过程，以实现数据的冗余备份、负载均衡和高可用性。

主从同步的基本流程：

1. 主数据库记录数据变更：主数据库在执行写操作（如INSERT、UPDATE、DELETE）时，会将这些变更记录到二进制日志（Binary Log）中。
2. 从数据库读取变更日志：从数据库通过网络连接，定期读取主数据库的二进制日志，获取最新的数据变更记录。
3. 从数据库应用变更：从数据库将读取到的变更记录应用到自己的数据存储中，使其数据与主数据库保持一致。

### SQL优化怎么做的

首先定位慢查询，可以在接口层使用运维监控工具如Skywalking监控接口耗时，找到性能瓶颈。数据库层开启慢查询日志（生产环境不建议开启，影响性能），定位具体的SQL语句。

再通过EXPLAIN分析SQL执行计划，查看是否使用索引。

然后针对慢查询进行优化，常见的优化手段包括：

- 添加索引：根据查询条件添加合适的索引，提升查询性能。
- SQL重写：通过优化SQL语句的写法，减少不必要的计算和数据扫描。
- 分库分表：对于大数据量的表，可以考虑进行分库分表，提升查询效率。
- 缓存：使用缓存技术，将热点数据缓存在内存中，减少数据库访问压力。

## 框架

### Spring事务失效

1. 方法不是public访问权限，无法实现事务代理
2. 事务方法被同类内部调用，未经过代理对象，需要获取代理对象，再通过代理对象调用事务方法
3. 异常类型不符合回滚规则，默认只对RuntimeException回滚，其他异常应该手动指定
4. 手动捕获异常且未重新抛出，导致Spring事务无法感知异常，正确的方法是捕获后重新抛出

### Spring中的Bean

Spring中的Bean默认是单例的，可以通过scope设置为prototype等其他作用域。

单例Bean并不是线程安全的，Bean中的属性如果是可变的，在多线程环境下可能会引发数据不一致的问题。

Spring Bean 的生命周期

1. 实例化：Spring容器通过反射创建Bean实例。

2. 依赖注入：Spring容器将配置文件或注解中定义的属性值注入到Bean实例中。

3. 初始化：如果Bean实现了InitializingBean接口，调用afterPropertiesSet()方法，或者配置了init-method方法，则执行初始化逻辑。

4. 使用：Bean实例可以被应用程序使用。

5. 销毁：如果Bean实现了DisposableBean接口，调用destroy()方法，或者配置了destroy-method方法，则执行销毁逻辑。当容器关闭时，单例Bean会被销毁，而原型Bean不会被容器管理销毁。

### Spring的循环依赖

循环依赖是指两个或多个Bean相互依赖，形成一个闭环。

Spring通过三级缓存机制解决单例Bean的循环依赖问题：

1. 三级缓存：
    - 一级缓存（singletonObjects）：存放完全初始化好的单例Bean。
    - 二级缓存（earlySingletonObjects）：存放已经实例化但未完成初始化的单例Bean。
    - 三级缓存（singletonFactories）：存放单例Bean的工厂，用于创建Bean。

2. 解决过程：
    - 当Spring容器创建一个Bean时，首先检查一级缓存，如果存在则直接返回。
    - 如果一级缓存不存在，检查二级缓存，如果存在则返回。
    - 如果二级缓存不存在，检查三级缓存，如果存在则通过工厂创建Bean，并将其放入二级缓存，然后返回。
    - 如果三级缓存也不存在，则实例化Bean工厂，并将其放入三级缓存，然后进行依赖注入。
    - 在依赖注入过程中，如果遇到循环依赖，Spring会通过三级缓存机制，提前暴露未完成初始化的Bean，解决循环依赖问题。
    - 最后，完成Bean的初始化，并将其从二级缓存移到一级缓存。

构造方法循环依赖，需要使用@Lazy注解或Setter注入来解决。

### SpringMVC执行流程

传统前后端不分离架构下，SpringMVC的执行流程如下：

1. 客户端发送请求到DispatcherServlet。
2. DispatcherServlet根据请求URL调用HandlerMapping，返回处理器。
3. DispatcherServlet调用处理器适配器HandlerAdapter，执行处理器。
4. Controller返回ModelAndView对象，包含视图名称和模型数据。
5. DispatcherServlet根据视图名称查找ViewResolver，解析出具体的视图。
6. ViewResolver渲染生成最终视图返回给DispatcherServlet。
7. DispatcherServlet将响应内容返回给客户端。

前后端分离架构下，SpringMVC的执行流程如下：

1. 客户端发送请求到DispatcherServlet。
2. DispatcherServlet根据调用HandlerMapping，返回处理器。
3. DispatcherServlet调用处理器适配器HandlerAdapter，执行处理器。
4. Controller处理请求，返回数据对象（如JSON）。
5. DispatcherServlet将数据对象通过消息转换器（MessageConverter）转换为响应格式。
6. DispatcherServlet将响应内容返回给客户端。

### AOP

AOP（面向切面编程）是一种编程范式，通过将公共行为逻辑从核心业务中分离出来，封装为可重用模块，提高代码的模块化和可维护性。

使用场景：

- 日志记录
- 事务管理
- 缓存管理

### SpringBoot自动配置原理

Spring Boot自动配置的核心原理是 “约定优于配置” ，它通过 @EnableAutoConfiguration 注解来启动一个自动配置机制，在应用程序启动时，扫描类路径下的 META-INF/spring.factories 文件，加载其中预定义的自动配置类，并根据条件注解（如 @ConditionalOnClass）来决定是否生效，从而自动配置Spring应用所需的Bean。

### 常见注解
Spring:
@Component：通用组件注解，标识一个类为Spring管理的Bean。
@Autowired：用于自动注入依赖的Bean。
@Qualifier：与@Autowired配合使用，指定注入Bean的名称。
@Configuration：标识配置类，通常用于定义Bean。
@Bean：用于在配置类中定义Bean。
@Service：标识服务层组件，通常用于业务逻辑层。
@Repository：标识数据访问层组件，通常用于DAO层。
@Controller：标识控制器组件，处理HTTP请求。

Spring MVC:
@RequestMapping：用于映射HTTP请求到处理方法或类。
@RequestParam：用于绑定HTTP请求参数到方法参数。
@RequestBody：将HTTP请求体绑定到方法参数，通常用于处理JSON数据。
@PathVariable：用于绑定URL路径变量到方法参数。
@ResponseBody：将方法返回值作为HTTP响应体返回，通常用于RESTful API。

Spring Boot:
@SpringBootApplication：组合注解，包含@Configuration、@EnableAutoConfiguration和@ComponentScan。
@EnableAutoConfiguration：启用Spring Boot的自动配置机制。
@ComponentScan：启用组件扫描，自动发现和注册Bean。

### Mybatis执行流程

1. 解析配置文件：MyBatis读取mybatis-config.xml配置文件，解析全局配置和映射器配置。

2. 创建SqlSessionFactory：根据配置文件创建SqlSessionFactory对象，用于生成SqlSession。

3. 创建SqlSession：通过SqlSessionFactory创建SqlSession对象，用于执行SQL语句。

4. Executor执行SQL：SqlSession调用Executor执行SQL语句，Executor负责与数据库交互。

5. 预处理SQL语句：Executor使用MappedStatement对象获取SQL语句，并进行预处理（如参数替换）。

6. 执行SQL语句：Executor通过JDBC执行预处理后的SQL语句，获取结果集。

7. 结果映射：Executor将结果集映射为Java对象，返回给调用者。

### Mybatis延迟加载

延迟加载是指在真正需要使用关联对象时，才去加载它们，而不是在查询主对象时就立即加载所有关联对象。

示例：
如果fetchType设置为lazy，则在查询User对象时，不会立即加载orders集合，只有在调用getOrders()方法时，才会执行selectByUserId查询订单数据。

```xml
<resultMap id="userResultMap" type="com.example.User">
    <id property="id" column="id"/>
    <result property="name" column="name"/>

    <collection property="orders" ofType="com.example.Order" select="com.example.OrderMapper.selectByUserId" column="id" fetchType="lazy">
    </collection>

</resultMap>
```

也可以通过在mybatis-config.xml中配置全局延迟加载：

```xml
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

原理：
MyBatis通过动态代理和CGLIB生成代理对象，在访问关联对象时，触发代理对象的拦截器，执行相应的查询操作，从而实现延迟加载。

### Mybatis缓存

MyBatis缓存分为一级缓存和二级缓存：
一级缓存（SqlSession级别）：
    默认开启，作用范围是同一个SqlSession内。
    当执行查询操作时，MyBatis会先检查一级缓存中是否存在对应的结果集，如果存在则直接返回，否则执行SQL查询并将结果存入一级缓存。
    一级缓存通过HashMap实现，key是SQL语句和参数的组合，value是查询结果。
二级缓存（Mapper级别）：
    需要手动配置，作用范围是同一个Mapper的所有SqlSession。
    当执行查询操作时，MyBatis会先检查二级缓存中是否存在对应的结果集，如果存在则直接返回，否则执行SQL查询并将结果存入二级缓存。
    当数据被更新时，二级缓存会被清空以保证数据一致性。

开启二级缓存：
在mybatis-config.xml中配置全局缓存：

```xml
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

在Mapper XML文件中配置缓存：

```xml
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="false"/>
```

## 多线程

### 进程与线程

- 进程是计算机分配资源的基本单位，每个进程都有独立的内存空间，进程切换开销较大
- 线程是进程执行的基本单位，线程间共享进程的内存空间和资源

### 并行与并发

- 并行是指多个任务同时进行，通常需要多核CPU支持
- 并发是指多个任务在同一时间段内交替进行，单核CPU也能实现


### 线程创建方式
1. 继承Thread类，重写run()方法
2. 实现Runnable接口，重写run()方法
3. 实现Callable接口，重写call()方法，返回值类型可自定义
4. 使用线程池，通过Executors创建线程池，提交任务执行

Runnable和Callable的区别：

1. 返回值：Runnable没有返回值，Callable可以返回自定义类型的值。
2. 异常处理：Runnable不能抛出检查型异常，Callable可以抛出检查型异常。
3. 适用场景：Runnable适用于不需要返回值的任务，Callable适用于需要返回值或抛出异常的任务。

### 线程状态

线程有以下几种状态：
新建（New）：线程对象创建后，尚未调用start()方法。
就绪（Runnable）：调用start()方法后，线程进入就绪状态，等待CPU调度执行。
阻塞（Blocked）：线程等待获取锁或资源时进入阻塞状态。
等待（Waiting）：线程调用wait()方法或join()方法进入等待状态，直到被唤醒。
计时等待（Timed Waiting）：线程调用sleep()方法或带超时的wait()方法进入计时等待状态，等待指定时间后自动唤醒。
终止（Terminated）：线程执行完run()方法或被强制终止后进入终止状态。

### 保证线程执行顺序

使用线程的join()方法，可以让调用的线程等待另一个线程执行完毕后再继续执行。

### sleep和wait的区别

1. 所属类不同：sleep()是Thread类的静态方法，wait()是Object类的实例方法。
2. 调用时机不同：sleep()可以在任何地方调用，wait()必须在同步块或同步方法中调用。
3. 释放锁不同：sleep()不会释放锁，wait()会释放锁。

### 停止线程的方法

1. 使用标志变量（建议使用volatile），线程判断标志后结束run方法正常结束
2. 使用线程的stop方法（已经弃用，不推荐）
3. 使用interrupt方法，在线程中捕获InterruptedException异常或通过isInterrupted方法判断中断状态

### Java内存模型（JMM）

JMM 是 JVM 定义的关于线程如何通过主内存（Heap）和各自工作内存（线程本地缓存）交互的规范

每一个线程都有自己的工作内存（栈内存），用于存储该线程使用的变量副本。所有线程共享主内存（堆内存），用于存储对象实例和类变量。

线程的工作内存是相互独立的，线程之间不能直接访问对方的工作内存。线程通过主内存进行通信，读取和写入共享变量。

### 线程安全

当多个线程访问同一个共享资源时可能会引发数据不一致的问题。
确保线程安全的方法：通过同步机制控制对共享资源的访问
锁机制：
    使用synchronized关键字
    Lock接口，ReentrantLock、ReentrantReadWriteLock

非阻塞同步（乐观锁）：
    CAS

避免资源共享：
    不可变对象

### Java中常见的锁

synchronized-内置锁
ReentrantLock-可重入锁
ReadWriteLock-读写锁
ReentrantReadWriteLock-可重入读写锁

### synchronized原理

synchronized是Java内置的同步机制，通过Monitor对象实现。每个对象都有一个与之关联的Monitor，当线程进入synchronized方法或块时，会尝试获取该对象的Monitor锁，获取成功后才能执行同步代码，执行完毕后释放锁。

Monitor中包含Owner（持有锁的线程）、Entry List（等待获取锁的线程队列）和Wait Set（等待被唤醒的线程队列）。

线程获取锁时，检查Monitor的Owner是否为null，如果为null则将自己设置为Owner并进入临界区；如果不为null则将自己加入Entry List等待。

当线程执行完synchronized方法或块后，Monitor会将Owner设置为null，唤醒Entry List中的一个线程。

### synchronized锁升级

同步加锁是一个比较耗费资源的操作，JVM通过锁升级机制来优化性能。
锁升级过程：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

1. 无锁：JVM通过锁消除技术，避免不必要的加锁操作。

2. 偏向锁：当一个线程第一次获取锁时，JVM会将锁标记为偏向锁，表示该锁偏向于该线程。后续该线程再次获取锁时，无需进行任何同步操作，直接进入临界区。

3. 轻量级锁：当多个线程竞争偏向锁时，JVM会将偏向锁升级为轻量级锁。轻量级锁使用自旋锁的方式，线程在获取锁时会在一定时间内循环尝试获取锁，而不是阻塞。

4. 重量级锁：当轻量级锁竞争激烈时，JVM会将其升级为重量级锁。重量级锁会阻塞其他线程，直到持有锁的线程释放锁。

### synchronized和Lock的区别

synchronized是Java内置的同步机制，使用简单，自动释放锁，但功能有限。
Lock是Java提供的同步接口，常用的实现类是ReentrantLock，功能更强大，如可中断锁、定时锁、公平锁、多个条件变量等，但需要手动释放锁。

### AQS

AQS（AbstractQueuedSynchronizer 抽象队列同步器）是Java并发包中的一个基础框架，用于构建锁和同步器。

AQS通过属性state来表示锁的状态，state的值可以表示锁的持有情况（如0表示未持有，1表示持有）。多个线程通过CAS操作来修改state，实现对锁的获取和释放。
AQS通过维护一个FIFO队列来管理线程的竞争，提供了基本的获取和释放锁的功能。开发者可以通过继承AQS并实现其抽象方法，来创建自己的锁或同步器。

### 线程安全三要素

原子性、可见性、有序性

synchronized可以保证原子性、可见性、（弱）有序性

volatile可以保证可见性以及禁止指令重排保证有序性

synchronized并不能禁止指令重排

示例：双重检查的单例模式

```java
public final class Singleton {

    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 死锁产生的条件

死锁四要素：
1. 互斥：资源只能被一个线程占用
2. 持有并等待：线程持有资源并等待其他资源
3. 不可剥夺：资源不能被强制夺取
4. 循环等待：线程形成环形等待资源

Java中检测死锁：使用jps查看Java进程，使用jstack命令生成线程堆栈信息，分析线程状态和锁等待情况。（或者使用jconsole）

### ConcurrentHashMap

ConcurrentHashMap是Java中线程安全的哈希表实现，支持高并发读写操作。

JDK1.7中使用分段数组+链表实现，加锁方式为Segment分段锁，使用ReentrantLock实现。

JDK1.8中使用数组+链表+红黑树实现，加锁方式为CAS+Synchronized，并且只对链表或红黑树的首节点加锁，提升并发性能。

### 线程池

为什么要使用线程池？
频繁创建线程和销毁线程开销大，线程池可以复用线程，减少资源消耗
控制最大并发线程数，防止系统过载

线程池使用场景：
数据批量导入
数据汇总
异步任务处理


```java
public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler)
```

corePoolSize: 核心线程数，线程池中保持存活的最小线程数
maximumPoolSize: 最大线程数，线程池中允许的最大线程数，当任务过多时会创建新线程，直到达到该值
keepAliveTime: 非核心线程的存活时间，当线程空闲时间超过该值时，线程会被销毁
unit: keepAliveTime的时间单位
workQueue: 任务队列，用于存放等待执行的任务
    - LinkedBlockingQueue: 有界队列（默认无界），适合任务量大且执行时间较短的场景
    - ArrayBlockingQueue: 有界队列，适合任务量可控的场景
    - PriorityBlockingQueue: 优先级队列，根据任务优先级执行任务
    - SynchronousQueue: 直接交付队列，不存储任务，适合任务量大且执行时间较长的场景
threadFactory: 线程工厂，用于创建新线程
handler: 拒绝策略，当任务无法被执行时的处理方式
    - AbortPolicy: 抛出异常，默认策略
    - CallerRunsPolicy: 由调用者线程执行任务
    - DiscardPolicy: 丢弃任务，不抛出异常
    - DiscardOldestPolicy: 丢弃队列中最旧的任务，然后尝试执行当前任务

线程池执行过程：
提交任务时，线程池首先检查当前运行的线程数是否小于corePoolSize，如果是，则创建新线程执行任务。如果当前线程数已经达到corePoolSize，则检查任务队列是否已满，如果未满，则将任务放入队列等待执行。如果任务队列已满且当前线程数小于maximumPoolSize，则创建新线程执行任务。如果当前线程数已经达到maximumPoolSize且任务队列已满，则根据拒绝策略处理任务。


为什么不使用Executors创建线程池？

1. 灵活性差：Executors创建的线程池参数不可修改，无法动态调整。
2. 资源浪费：默认的线程池配置可能不适合特定场景，导致资源浪费。
3. 不易监控：Executors创建的线程池不易监控和管理，难以获取线程状态。
4. 潜在风险：某些Executors方法可能导致OOM等问题，如newFixedThreadPool使用无界队列。

任务队列逐渐变大如何处理？

1. 限制队列大小：使用有界队列，防止任务过多导致内存溢出。
2. 监控线程池状态：定期监控线程池的任务队列长度和线程使用情况，及时发现问题。
3. 拒绝策略：根据业务需求选择合适的拒绝策略，如丢弃任务或由调用者执行任务。
4. 动态调整线程池参数：根据系统负载动态调整核心线程数和最大线程数。

预防：使用有界队列和合适拒绝策略

监控：实时监控队列大小设置告警

应急：发生时进行任务降级和限流

根治：通过业务拆分和引入消息队列从根本上解决问题

### 如何控制某个方法的并发数

Java中可以通过Semaphore（信号量）来控制某个方法的并发数。
Semaphore维护一个许可集，线程在调用方法前需要获取许可，执行完毕后释放许可，从而限制同时访问该方法的线程数量。

### ThreadLocal

ThreadLocal是Java提供的一种线程局部变量机制，每个线程都有自己的独立变量副本，互不干扰。
ThreadLocal通过为每个线程维护一个Map来存储变量副本，线程通过ThreadLocal的get()和set()方法访问和修改自己的变量副本。

例如：
每个线程将JDBC的Connection放入ThreadLocal中，确保每个线程使用独立的Connection，避免多线程环境下的连接冲突。

ThreadLocal中的方法：
```java
set(T value)：将当前线程的局部变量设置为指定值。
get()：获取当前线程的局部变量值。
remove()：移除当前线程的局部变量，防止内存泄漏。
```

ThreadLocal内存泄漏
ThreadLocal 的内存泄漏主要发生在 线程池环境 下，且没有显式调用 remove() 方法 时。
```java
// Thread 类中持有 ThreadLocalMap 引用
class Thread {
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

// ThreadLocalMap 的 Entry 继承 WeakReference
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;  // 强引用
    
    Entry(ThreadLocal<?> k, Object v) {
        super(k);  // key 是弱引用
        value = v; // value 是强引用
    }
}

Thread (强引用)
  ↓
ThreadLocalMap (强引用)
  ↓
Entry[] 数组 (强引用)
  ↓
Entry.key → ThreadLocal (弱引用) ✓ 可被 GC
Entry.value → 实际对象 (强引用) ✗ 无法被 GC
```



### 悲观锁和乐观锁

悲观锁：
假设会发生并发冲突，访问数据时先加锁
synchronized、ReentrantLock

乐观锁：
假设不会发生并发冲突，访问数据时不加锁，更新时检查版本
CAS，版本号机制


## JVM

### G1垃圾回收器

G1（Garbage First）垃圾回收器是Java 7引入的一种面向服务端应用的垃圾回收器，JDK9后作为默认垃圾回收器，旨在提供高吞吐量和低延迟的垃圾回收性能。
特点：
分代收集：将堆内存划分为年轻代和老年代，并分别进行垃圾回收。
区域划分：将堆划分为多个独立的区域（Region），每个区域可以独立进行垃圾回收。
并行和并发：支持多线程并行垃圾回收，减少停顿时间。
预测停顿时间：可以根据应用需求设置最大停顿时间目标。
混合收集：在老年代进行垃圾回收时，同时回收年轻代，提升效率。

## 微服务

### Spring Cloud 五大组件

1. 注册中心：Eureka
2. 负载均衡：Ribbon
3. 远程调用：Feign
4. 服务熔断：Hystrix
5. 网关：Zuul/Gateway

### 注册中心

服务注册：服务启动时，将自身信息（如IP、端口、服务名）注册到注册中心
服务发现：服务消费者从注册中心获取可用服务列表，实现负载均衡调用
服务健康检查：注册中心定期检查服务状态，剔除不可用服务

nacos和eureka区别：
1. Nacos除了作为注册中心，还可以作为配置中心使用
2. Nacos监测到服务变更后会主动推送给客户端，Eureka需要客户端定期拉取

### 网关作用

路由
鉴权，认证
限流
负载均衡
安全防护

### Ribbon负载均衡

负载均衡策略：
1. 轮询（Round Robin）：依次将请求分发到每个服务器
2. 随机（Random）：随机选择一台服务器处理请求
3. 加权响应时间（Weighted Response Time）：根据服务器响应时间分配权重，响应时间越短权重越高
4. 区域敏感（Zone Aware）：优先选择与客户端同一区域的服务器

配置负载均衡策略：
1. 通过配置文件或代码指定负载均衡策略，如在application.yml中配置某个服务的策略（局部）
2. 实现自定义负载均衡策略，继承IRule接口并实现choose方法（全局）


### 服务雪崩

服务雪崩是指当一个服务出现故障或响应变慢时，导致依赖该服务的其他服务也出现故障或响应变慢，最终引发整个系统崩溃的现象。

预防措施：
1. 服务降级：当依赖服务不可用时，提供默认响应或备用逻辑
2. 服务熔断：当依赖服务连续失败达到一定阈值时，断开与该服务的连接，防止请求继续传递
3. 限流：限制单位时间内对某个服务的请求数量，防止过载

### 服务监控

服务监控用于实时监控微服务的健康状态、性能指标和调用链路，帮助运维人员及时发现和解决问题。

常用方案：
1. Prometheus + Grafana：Prometheus负责数据采集和存储，Grafana负责数据可视化展示（企业级方案，搭建较复杂）
2. Zipkin：分布式追踪系统，记录服务调用链路和延迟（代码侵入性）
3. SkyWalking：分布式应用性能监控和追踪系统（推荐）


Skywalking可以监控接口、服务、实例的健康状态，在服务压测时也可以监控接口的响应时间、吞吐量等指标，帮助发现性能瓶颈。
此外还可以配置告警规则，及时通知运维人员处理异常情况。


### CAP和BASE理论

CAP理论，分布式系统中，无法同时满足以下三项要求：
一致性（Consistency）：所有节点在同一时间看到的数据是一致的。
可用性（Availability）：每个请求都会在有限时间内得到响应，无论响应是成功还是失败。
分区容错性（Partition Tolerance）：系统能够在网络分区发生故障时继续运行。


BASE理论：
基本可用（Basically Available）：系统保证基本的可用性，允许部分节点不可用。
软状态（Soft State）：系统中的数据状态可以在一段时间内处于不一致的中间状态。
最终一致性（Eventual Consistency）：系统在没有新的更新操作后，最终会达到一致的状态。

BASE理论是对CAP理论的一种补充，强调在分布式系统中可以通过牺牲一致性来提高可用性和分区容错性。

### 分布式事务解决方案

两阶段提交（2PC）：协调者先询问所有参与者是否准备好提交事务，如果所有参与者都准备好，则协调者发送提交命令，否则发送回滚命令。

阿里巴巴的Seata框架提供了分布式事务解决方案，支持AT、TCC、和XA等模式。

XA模式：基于两阶段提交协议，所有分支事务需要等待协调者的提交或回滚命令，适用于强一致性要求的场景，但性能较低。
AT模式：分支事务各自提交并向协调者报告状态，协调者通过全局锁和补偿机制保证最终一致性，适用于大部分场景，性能较高。
TCC模式：分支事务分为Try、Confirm和Cancel三个阶段，需要预留资源然后确认或取消，适用于对业务操作有明确补偿逻辑的场景。

### 幂等性接口设计

幂等性是指对同一操作执行多次，结果与执行一次的结果相同。

设计幂等性接口的方法：
1. 数据库唯一索引：通过在数据库中设置唯一索引，防止重复数据插入
2. 使用唯一请求ID：为每个请求分配唯一ID，服务器记录已处理的请求ID，重复请求直接返回之前的结果
3. 分布式锁：使用分布式锁控制对共享资源的访问，防止并发操作导致数据不一致

### 分布式任务调度



## 消息中间件

### 如何确保RabbitMQ消息不丢失

1. 生产者通过Publisher Confirms机制确认消息已被Broker接收，出错则记录日志人工处理
2. Broker将消息持久化到磁盘，防止宕机丢失
3. 消费者使用确认机制和重试机制，确保消息被成功处理，失败则投递到异常处理队列由人工处理

### 如何解决消息重复消费问题

1. 幂等性设计：确保消费者处理同一消息多次不会产生副作用
2. 消息唯一标识：为每条消息分配唯一ID，消费者记录已处理的消息ID，避免重复处理
3. 使用事务或确认机制：确保消息被成功处理后再确认消费

### 延迟队列

延迟队列用于在指定时间后再处理消息

RabbitMQ中可以通过死信队列实现延迟队列：
1. 创建一个普通队列和一个死信队列
2. 普通队列设置消息TTL（存活时间）和死信交换机
3. 消息在普通队列中达到TTL后被投递到死信队列
4. 消费者从死信队列中消费消息，实现延迟处理


或者通过官方插件实现延迟队列。

### 如何解决消息堆积问题

1. 增加消费者数量，提高消费速度
2. 通过线程池加快消费处理速度
3. 采用惰性队列，延迟加载消息

### RabbitMQ高可用性

1. 标准集群模式：多个节点间共享交换机和队列元数据，但不共享消息数据
2. 镜像模式：主从模式，队列在多个节点间镜像，保证消息数据冗余，在消息同步时可能导致丢失
3. 仲裁队列：镜像模式的增强，可以实现数据的强一致性


## Java基础

### String不可变类

String一旦被创建就不能被改变。

首先String类使用final修饰，不可被继承，字符串内容存储在private final char[] value数组中，且没有提供修改value数组的方法。

String类提供的所有修改字符串的方法，实际上都是创建了一个新的String对象，而不是修改原有对象。

不可变类的优点：
线程安全
安全性高：无法被篡改
性能优化：字符串常量池

潜在的问题：
频繁创建新对象，增加内存开销和垃圾回收压力。可使用StringBuilder或StringBuffer进行字符串拼接以提高性能。

### 类型擦除

> 要理解泛型主要提供的是编译期的类型安全检查，而不是运行时的类型信息。

Java泛型在编译时会进行类型擦除，编译器会将泛型类型替换为其限定类型（默认是Object），并插入必要的类型转换代码。

带来的影响：

1. 无法在运行时获取泛型类型信息（如 instanceof 检查）

2. 不能创建泛型数组（数组在运行时需要知道确切的类型）

3. 不能实例化泛型类型的对象（new T()），可以通过传入Class<T>参数通过反射来解决

```java
public class Box<T> {
    private T value;

    public Box(Class<T> clazz) throws Exception {
        this.value = clazz.newInstance(); // 通过反射创建实例
    }
}
// 使用时：Box<String> box = new Box<>(String.class); // 但这对于String不适用，因为String没有无参构造
```

4. 方法重载冲突，如下代码类型擦除后变为相同的方法签名，导致编译错误

```java
public void print(List<String> list) { }
public void print(List<Integer> list) { }
```

5. 不能用于静态上下文（静态成员属于类，在类加载时就被初始化。而泛型类型参数 T 是属于实例的，不同的实例可以有不同的 T）

```java
public class Box<T> {
    // 编译错误：Non-static type 'T' cannot be referenced from a static context
    private static T staticValue;

    // 同样错误
    public static T getStaticValue() { return staticValue; }
    
    // 这是允许的，因为这里的U是方法自己的类型参数
    public static <U> void doSomething(U param) { ... }
}
```

### 抽象类和接口

1. 接口使用关键字interface定义，抽象类使用关键字abstract class定义

2. 其他类使用implements关键字实现接口，使用extends关键字继承抽象类

3. 接口可以多实现，抽象类只能单继承

4. 接口中的属性默认是public static final（常量），抽象类中可以有变量

5. 接口中的普通方法默认是public abstract（抽象方法）除了default方法和static方法，抽象类中可以有具体方法和抽象方法。

6. 接口更侧重于定义规范，抽象类更侧重于代码复用。

7. Java 8及以上版本，接口可以有默认方法和静态方法，抽象类可以有构造方法。

### 大量数据，用ArrayList还是LinkedList

通常情况下直接使用ArrayList：

底层使用动态数组，支持随机访问，查询效率高，时间复杂度O(1)
内存占用较低，数据密集存储
数据连续存储，缓存友好

而LinkedList:
底层使用双向链表，占用更多内存，每个节点需要额外存储指针
不支持随机访问，查询效率低，时间复杂度O(n)
缓存不友好

实际情况下，面对海量数据应该优先考虑使用流式处理和分批加载的方式，避免一次性将所有数据加载到内存中。


### 数组与List转换

数组转List：
```java
String[] array = {"a", "b", "c"};
List<String> list = Arrays.asList(array);
```

存在的问题：
1. Arrays.asList() 返回的是一个固定大小的List，不能进行add、remove等修改操作。
2. 该List底层还是使用原数组，对数组的修改会影响List。


List转数组：
```java
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
String[] array = list.toArray(new String[0]);
```

### HashMap原理

HashMap是基于哈希表实现的键值对存储结构，底层使用数组和链表（或红黑树）来存储数据。
1. 计算哈希值：通过key的hashCode()方法计算哈希值，并通过扰动函数（hash & (n - 1)）将哈希值映射到数组索引。
2. 处理哈希冲突：当多个key映射到同一索引时，使用链表或红黑树存储冲突的元素。
3. 扩容机制：当元素数量超过负载因子（默认0.75）与容量的乘积时，HashMap会进行扩容，创建一个更大的数组，并重新计算所有元素的索引位置。
4. 读取数据：通过key计算哈希值，找到对应的数组索引，然后遍历链表或红黑树查找对应的value。

JDK1.7和JDK1.8中HashMap的区别：
1. JDK1.7中，HashMap使用数组+链表实现。
2. JDK1.8中，引入了红黑树，当链表长度超过8时，会将链表转换为红黑树，提高查询效率。

### JDK1.7中HashMap死链问题

在JDK1.7中，HashMap在多线程扩容时可能会导致死链问题。死链是指链表中的节点形成了一个环，导致无法遍历完整个链表。
原因：
1. 多线程同时触发扩容，多个线程同时修改同一个桶的链表。
2. 在扩容过程中，节点的next指针被错误地修改，形成环形结构。
解决方法：
1. 使用ConcurrentHashMap替代HashMap，避免多线程环境下的并发问题。
2. 在单线程环境下使用HashMap，避免多线程扩容冲突。


## 场景题

### 单点登录（SSO）怎么实现

单点登录（SSO）是一种认证机制，允许用户在一个系统中登录后，访问其他相关系统时无需再次登录。

单实例模式下可以通过Session实现，但是多实例下Session无法共享，需要使用分布式Session管理或Token机制。

常见的SSO实现方式：
1. JWT（JSON Web Token）：用户登录后，生成JWT令牌，客户端携带令牌访问其他系统，服务器验证令牌有效性。
2. OAuth2.0：用户登录后，授权服务器颁发访问令牌，客户端携带令牌访问资源服务器，资源服务器验证令牌有效性。
3. CAS（Central Authentication Service）：用户登录后，CAS服务器生成票据，客户端携带票据访问其他系统，其他系统向CAS服务器验证票据有效性。
....

### 权限认证如何实现

最常见的权限认证方式是基于角色的访问控制（RBAC）：

该模式有三个核心概念：用户（User）、角色（Role）和权限（Permission）。
用户通过分配角色获得相应的权限，角色与权限之间是多对多关系。
设计上需要定义用户表、角色表、权限表以及用户角色关联表和角色权限关联表，共五张表。

常见实现框架：Apache Shiro（更轻量级）、Spring Security（推荐）

### 数据安全

对称加密：加密和解密使用相同的密钥，速度快，适合大数据量加密，如AES、DES。

非对称加密：加密和解密使用不同的密钥，安全性高，适合小数据量加密，如RSA。

### 日志采集

为什么要采集日志：
1. 监控与告警：通过日志可以实时监控系统运行状态，及时发现异常并告警。
2. 问题排查：日志是排查问题的重要依据，可以帮助开发人员快速定位故障原因。
3. 数据分析：通过对日志的分析，可以挖掘用户行为、系统性能等数据，为决策提供支持。

采集方式：
1. 常规采集：应用程序将日志写入本地文件。
2. ELK采集：使用Logstash将日志采集到Elasticsearch进行存储和分析，Kibana用于可视化展示。

### 生产环境排查问题

1. 查看日志：检查应用程序日志、系统日志，寻找异常信息。
2. 远程调试：使用远程调试工具连接生产环境，进行代码级别的调试。

### 如何定位系统性能瓶颈

1. 压测：使用压力测试工具（LoadRunner、JMeter）模拟高并发场景，观察系统性能表现。
2. 监控：使用监控工具（如Prometheus、Grafana）实时监控系统各项指标（CPU、内存、响应时间等）。
3. 线上诊断：使用诊断工具Arthas分析应用程序的性能瓶颈。

## 网络基础

### OSI分层模型

国际标准：
应用层
表示层
会话层
传输层
网络层
数据链路层
物理层

TCP/IP四层模型：
应用层
传输层
网络层
网络接口层

五层模型：
应用层
传输层
网络层
数据链路层
物理层


### TCP三次握手和四次挥手

三次握手（建立连接）：
目的：确认双方的发送和接收能力都正常，同步双方的初始序列号。

客户端 -> 服务器：发送 SYN=1, seq=x。客户端进入 SYN_SENT 状态。（意思：你好，我想和你建立连接。）

服务器 -> 客户端：发送 SYN=1, ACK=1, seq=y, ack=x+1。服务器进入 SYN_RCVD 状态。（意思：收到你的请求了，我同意建立连接，你也准备好哦。）

客户端 -> 服务器：发送 ACK=1, ack=y+1。客户端和服务器都进入 ESTABLISHED 状态。（意思：收到你的同意，连接已建立，可以开始发数据了。）

四次挥手（断开连接）：
目的：双方都确认要断开连接。

客户端 -> 服务器：发送 FIN=1, seq=u。客户端进入 FIN_WAIT_1 状态。（意思：我的数据发完了，想关闭连接。）

服务器 -> 客户端：发送 ACK=1, ack=u+1。服务器进入 CLOSE_WAIT 状态。（意思：收到你的关闭请求。） （此时，客户端->服务器的单向连接断开，但服务器可能还有数据要发送给客户端）

服务器 -> 客户端：发送 FIN=1, seq=v。服务器进入 LAST_ACK 状态。（意思：我的数据也发完了，同意关闭连接。）

客户端 -> 服务器：发送 ACK=1, ack=v+1。客户端进入 TIME_WAIT 状态（等待2MSL后关闭），服务器收到后立即关闭。（意思：收到，再见。）

### TCP

TCP是一种面向连接的、可靠的、基于字节流的传输层协议。
特点：
面向连接
可靠传输
拥塞控制
全双工

### TCP和UDP的区别

|TCP|UDP|
|---|---|
|面向连接|无连接|
|可靠传输|不可靠|
|速度较慢|速度较快|
|拥塞控制|无拥塞控制|

TCP应用场景（可靠性要求高）：

1. 文件传输
2. 网页浏览
3. 邮件服务
4. 远程登录

UDP应用场景：

1. 视频流媒体
2. 语音通话
3. DNS查询

### TCP分片粘包

分片：IP层将过大的TCP报文分段传输
粘包：多个数据包被TCP合并成一个报文发送，导致接收方无法正确区分数据包边界

解决方案：
固定消息长度
使用特殊分隔符
消息头添加长度字段

### TCP可靠性

序列号和确认应答：每个字节都有序号，接收方发送ACK确认

超时重传：未收到ACK时重传数据

校验和：检测数据在传输过程中是否出错

连接管理：三次握手建立连接，四次挥手断开连接

## 项目难点

面试官您好，我在之前的[某某项目]中，确实遇到了一个印象比较深刻的难点，是关于「大数据量导出」的功能。

（第一部分：背景与目标）
我们项目是一个运维管理系统，经常需要让运营人员导出审计数据进行分析。这些数据量非常庞大，单表就有上千万条记录。

（第二部分：难点详述）
最初版本的导出功能上线后，我们很快就收到了用户的负面反馈。主要问题有三个：

前端超时： 导出大量数据时，HTTP请求会超时，导致页面“假死”或直接报错。

服务器压力大： 一个导出请求会长时间占用数据库连接，内存飙升，甚至影响其他正常服务的响应。

用户体验差： 用户不知道导出进度，只能盲目等待，失败后也无法重试。

（第三部分：解决思路与行动）
针对这个问题，我们团队进行了深入的分析和解决：

分析定位： 我们首先用监控工具发现，瓶颈主要出现在数据库的复杂查询和JVM内存的瞬间峰值上。一次性把几十万条数据加载到内存，再生成Excel，是问题的根源。

技术选型： 我们否定了直接优化SQL的“治标”方案，决定采用 “异步导出” 和 “分页查询与流式生成” 的核心方案。

具体实施：

异步化： 用户点击导出后，后端立即生成一个导出任务，并放入任务队列中，然后立刻返回一个任务ID给前端。前端可以轮询这个任务的状态。

分页查询与流式写入： 在后端的任务处理器中，我们不再一次性查询所有数据，而是使用MyBatis的游标或分页查询，分批从数据库读取数据（比如每次5000条）。同时，我们使用Apache POI的SXSSFWorkbook模式，以流式的方式逐步将数据写入CSV/Excel文件，并即时上传到OSS（对象存储）。

通知与下载： 任务完成后，系统通过站内信或前端轮询到状态更新，通知用户下载生成好的文件。

（第四部分：结果与影响）
这个方案上线后，效果非常显著：

对用户： 再也没有请求超时，导出百万级数据也变得可行，用户可以通过任务中心查看进度和下载结果，体验非常好。

对系统： 服务器的内存和数据库连接压力恢复了正常，不再因为导出任务而影响核心业务。

（第五部分：复盘与成长）
通过解决这个难题，我最大的体会是：对于耗时长的业务，一定要做异步化和解耦；对于大数据处理，流式思想和分而治之是至关重要的。 这也让我在后来的项目设计中，会更多地考虑性能边界和用户体验，而不仅仅是实现功能本身。

# 试后提问

1. 我面试的这个岗位，未来会主要参与哪个产品或项目？它目前面临的最大的技术挑战是什么？

2. 公司对于应届生，会有哪些培养机制或导师制度呢？

3. 建议留到HR面或终面再问：

    薪资结构、绩效考核、年终奖、加班制度、福利待遇（五险一金缴纳比例）、年假等。

# HR综合面试

最近在忙些什么？

今年怎么样拿到的offer？哪些公司的。

拿到offer你觉得哪里没达到你的预期。

除了岗位发展原因外，还有哪些方面没有达到你的预期？

简单分享一个过往你做过最有挑战的技术项目。

在这个项目中，最大的困难和挑战是什么？

长远来看，未来10到15年你最理想的工作和生活会是什么样子？

父母对你当下找工作有什么期望或建议？

# 待整理