### Redis应用场景

1. 缓存
2. 分布式锁
3. 消息队列
4. 延时队列
5. 计数器

### 缓存穿透

缓存穿透是指查询一个根本不存在的数据，由于缓存和数据库都没有这个数据，因此每次请求都会直接落到数据库上，造成数据库压力过大，甚至宕机。

**解决方案**：

1. 缓存空对象
    - 如果查询的数据不存在，可以在缓存中存储一个空对象，并设置一个较短的过期时间（比如5分钟）。这样下次查询同样不存在的数据时，就会直接从缓存中获取，避免了对数据库的访问。
2. 布隆过滤器
    - 布隆过滤器使用位图和多个哈希函数来判断一个元素是否存在于集合中。它可以高效地过滤掉不存在的数据，从而减少对数据库的访问。
    - 布隆过滤器有一定的误判率，即可能会误判一个不存在的数据为存在，但不会误判一个存在的数据为不存在。通过调整位图大小和哈希函数数量，可以控制误判率在可接受范围内。
    - 实现：Redisson、Guava


### 缓存击穿

缓存击穿是指某个热点数据在缓存中失效后，大量并发请求直接落到数据库上，造成数据库压力过大，甚至宕机。

**解决方案**：

1. 互斥锁
    - 缓存重建时，使用互斥锁来保证同一时间只有一个线程可以访问数据库并重建缓存。其他线程等待锁释放后，再从缓存中获取数据。
2. 逻辑过期
    - 给缓存数据设置一个逻辑过期时间，即使数据过期了，仍然可以继续使用旧数据。
    - 当有请求发现数据过期时，先获取互斥锁，然后异步更新缓存，其他请求获取锁失败则继续使用旧数据。
    - 该方案存在数据不一致的风险，但可以通过合理设置逻辑过期时间来降低风险。


### 缓存雪崩

缓存雪崩是指大量缓存数据在同一时间失效或者缓存服务宕机，导致大量请求直接落到数据库上，造成数据库压力过大，甚至宕机。

**解决方案**：

1. 为不同缓存key设置随机性过期时间，避免大量缓存同时失效。
2. 提高缓存服务的可用性，使用集群、主从复制等方式，避免单点故障。
3. 限流降级策略，当缓存服务不可用时，限制请求速率或者直接返回默认值，避免大量请求落到数据库上。
4. 多级缓存方案，使用本地缓存和分布式缓存相结合的方式，降低对数据库的压力。


### 双写一致

双写一致是指在更新数据时，同时更新缓存和数据库，确保两者的数据一致性。

1. 延时双删
    - 在更新数据时，先删除缓存，然后更新数据库，最后再延时删除缓存（数据库可能是主从架构读写分离，需要一定时间同步）。这样可以确保缓存中的数据是最新的。
    - 该方案存在短暂的数据不一致风险，但可以通过合理设置删除缓存的时间间隔来降低风险。
2. 分布式读写锁
    - 使用分布式读写锁来保证同一时间只有一个线程可以更新数据。读操作可以并发进行，写操作需要获取写锁。
    - 该方案实现复杂度较高，但可以确保数据的强一致性。
3. 消息队列
    - 在更新数据时，将更新操作发送到消息队列中，由专门的消费者线程来处理更新缓存和数据库的操作。
    - 该方案只能保证数据的最终一致性，而且有消息丢失的风险，但可以提高系统的吞吐量和可用性。

### 持久化

Redis提供了两种持久化机制：

- RDB
- AOF

RDB（Redis DataBase）是Redis默认的持久化机制，它会在指定的时间间隔内将内存中的数据快照保存到磁盘上。RDB文件是一个二进制文件，包含了Redis数据库的完整状态。
```bash
redis-cli

save    # 手动触发RDB持久化，会阻塞主进程
bgsave  # fork子进程异步触发RDB持久化，不会阻塞主进程（写时复制，主进程执行写操作时才拷贝数据）
```

AOF（Append Only File）是Redis的另一种持久化机制，它会将每个写操作以日志的形式追加到AOF文件中。AOF文件是一个文本文件，包含了所有对Redis数据库的写操作。
```conf
appendonly yes          # 开启AOF持久化
appendfilename "appendonly.aof"  # AOF文件名
appendfsync everysec     # 每秒同步到磁盘
```

!!!note
    appendfsync配置的是AOF文件同步到磁盘的频率，写命令首先会被放入操作系统的缓冲区，然后由操作系统负责将数据写入磁盘。appendfsync配置的就是操作系统将数据写入磁盘的频率。

    支持的选项有：

    - always：每次有写操作时都同步到磁盘，性能最差
    - everysec：每秒同步到磁盘，性能较好，数据丢失风险较低（默认）
    - no：完全依赖操作系统，性能最好，但数据丢失风险最高

!!!info
    AOF文件占用较大，可通过`bgrewriteaof`命令重写AOF文件，删除冗余命令，减小文件大小。



### Redis的key过期后是否会被立即删除

并不会，Redis有两种删除策略：惰性删除和定期删除

- 惰性删除：每次访问key时，检查是否过期，过期则删除
- 定期删除：每隔一段时间，随机检查部分key，删除过期

Redis中两种删除策略结合使用，确保过期key最终被删除，但不会立即删除，避免性能问题。


### Redis内存淘汰（Redis内存不足）

Redis提供了多种内存淘汰策略，常用的有：

- noeviction：不淘汰任何key，内存满时写操作报错（默认）
- volatile-ttl：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
- allkeys-random：对所有key，随机淘汰
- volatile-random：对设置了TTL的key，随机淘汰
- allkeys-lru：对所有key，基于LRU算法淘汰
- volatile-lru：对设置了TTL的key，基于LRU算法淘汰
- allkeys-lfu：对所有key，基于LFU算法淘汰
- volatile-lfu：对设置了TTL的key，基于LFU算法淘汰（推荐）


!!!info "LRU和LFU算法"
    **LRU**（最近最少使用）

    - 通过记录每个key的最后访问时间，来判断哪个key最久未被使用，从而进行淘汰。

    **LFU**（最不经常使用）

    - 通过记录每个key的访问频率，来判断哪个key最少被使用，从而进行淘汰。


### Redis分布式锁

Redis分布式锁是通过Redis的setnx命令实现的，基本原理如下：
1. 客户端尝试通过setnx命令设置一个唯一的key，如果设置成功，表示获取锁成功
2. 客户端设置一个过期时间，防止死锁
3. 客户端执行完业务逻辑后，删除key，释放锁

Redission是一个基于Redis实现的分布式锁库，提供了更完善的分布式锁功能，包括自动续期、锁重入等。


