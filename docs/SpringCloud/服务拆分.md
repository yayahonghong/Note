## 拆分原则

<br>

什么时候拆？

对于**大多数小型项目来说，一般是先采用单体架构**，随着用户规模扩大、业务复杂后**再逐渐拆分为微服务架构**。

这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（**前易后难**）。

而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（**前难后易**）。

<br>

怎么拆？

* **高内聚**：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。

* **低耦合**：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。
  
<br>

明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式：

* **纵向**拆分

* **横向**拆分

<br>

1. **纵向拆分**，就是按照项目的功能模块来拆分。例如商城系统中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。

2. **横向拆分**，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。
   
<br>

---

## 服务调用

服务拆分前，多个服务间可以相互进行本地调用，但是拆分后就行不通了

因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的**远程过程调用**（RPC，即**R**emote **P**roduce **C**all），具体实现有 Dubbo、gRPC等。

!!!note
    传统意义的 RPC 框架，都是基于二进制协议的（非http协议，而是**TCP/UDP**），性能较好，但是使用起来比较复杂，且不易于调试。


**解决方案**：通过网络调用接口

Spring给我们提供了一个`RestTemplate`的API，可以方便的实现Http请求的发送。

首先将`Restemplate`交给spring管理

```java
@Configuration
public class RemoteCallConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

使用`Restemplate`

```java
    // 发起请求
    ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
            "http://localhost:8081/items?ids={ids}",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference<List<ItemDTO>>() {
            },
            Map.of("ids", CollUtil.join(itemIds, ","))
    );
    // 解析响应
    if(!response.getStatusCode().is2xxSuccessful()){
        // 查询失败，直接结束
        return;
    }
```

---

**上一节**：[单体架构与微服务](单体架构与微服务.md)

**下一节**：[服务治理](服务治理.md)

