# JVM总结

## 什么是JVM


- [x] JVM的定义

- [x] 作用

- [x] 功能

- [x] 组成

<br>

1. 定义

    JVM指的是<font color=red>Java虚拟机（Java Virtual Machine ）</font>。JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件，Java虚拟机上可以运行**Java、Kotlin、Scala、Groovy**等语言。

2. 作用

    支持Java中<font color=red>Write Once，Run Anywhere</font>；编写一次，到处运行的**跨平台**特性。

3. 功能
   
    - **解释和运行**
        
        - 对字节码文件中的指令，实时的解释成机器码，让计算机执行

    - **内存管理**
        
        - 自动为对象、方法等分
        
        - 自动的垃圾回收机制，回收不再使用的对象

    - **即时编译**
        
        - 对热点代码进行优化(JIT即时编译)，提升执行效率

4. 组成

    ![c8cc9e2e-36a4-4c73-b200-0fe6e06b6aa3](./images/c8cc9e2e-36a4-4c73-b200-0fe6e06b6aa3.png)

5. JVM选择
   
    - **最常用的JVM**:<font color=red>Oracle提供的Hotspot 、OpenJDK的Hotspot</font>

    - **有JVM二次开发需要**:<font color=red>OpenJDK的Hotspot</font>

    - **云原生架构高性能需求**:<font color=red>GraalVM OpenJ9</font>

    - **电商物流金融高性能需求**:<font color=red>GraalVM阿里DragonWell龙井</font>
     
     

## 字节码文件的组成


- [x] 查看字节码文件常用工具

- [x] 字节码文件的组成

- [x] 应用场景：工作中一般不直接查看字节码文件，只用于深入了解JVM

<br>

1. 查看字节码文件的工具
   
    - 开发环境使用`jclasslib`插件

    - 服务器环境使用`javap -v`命令

2. 组成

![字节码组成](./images/731c5b64-cca1-4316-b3b8-7ed6740b054e.png)


## 什么是运行时数据区


- [x] 程序计数器

- [x] 栈

- [x] 堆

- [x] 方法区

- [x] 直接内存（可选项，不属于运行时数据区）

<br>

1. 定义

    运行时数据区指的是JVM所管理的内存区域，其中分成两大类：

    - 线程共享 –方法区、堆

    - 线程不共享 –本地方法栈、虚拟机栈、程序计数器
        
    > 直接内存主要是NIO使用，由操作系统直接管理，不属于JVM内存。

2. 程序计数器

    程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。主要有两个作用：

    - 程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。

    - 在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。

3. 栈

    **Java虚拟机栈**采用栈的数据结构来管理方法调用中的基本数据，先进后出 ,每一个方法的调用使用一个<font color=red>栈帧</font>来保存。每个线程都会包含一个自己的虚拟机栈，它的生命周期和线程相同。
    栈帧主要包含三部分内容：

    - 局部变量表，在方法执行过程中存放所有的局部变量。

    - 操作数栈，虚拟机在执行指令过程中用来存放临时数据的一块区域。

    - 帧数据，主要包含动态链接、方法出口、异常表等内容。
     
     > 动态链接：方法中要用到其他类的属性和方法，这些内容在字节码文件中是以编号保存的，运行过程中需要替换成内存中的地址，这个编号到内存地址的映射关系就保存在动态链接中。

     > 方法出口：方法调用完需要弹出栈帧，回到上一个方法，程序计数器要切换到上一个方法的地址继续执行，方法出口保存的就是这个地址。

     > 异常表：存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。
     
     

   **本地方法栈**，Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。

4. 堆
   
    - 一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。

    - 栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。

    - 堆是垃圾回收最主要的部分，堆结构更详细的划分与垃圾回收器有关。

5. 方法区

    方法区是Java虚拟机规范中提出来的一个虚拟机概念，在HotSpot不同版本中会用永久代或者元空间来实现。方法区主要存放的是基础信息，包含：

    - 每一个加载的类的元信息（基础信息）。

    - 运行时常量池，保存了字节码文件中的常量池内容，避免常量内容重复创建减少内存开销。

    - 字符串常量池，存储字符串的常量。

!!!warning "直接内存"
    其并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。
    
    在 JDK 1.4 中引入了 NIO 机制，由操作系统直接管理这部分内容，主要为了提升读写数据的性能。
    
    在网络编程框架如Netty中被大量使用。要创建直接内存上的数据，可以使用ByteBuffer。语法： `ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);`



## 会出现内存溢出的区域

内存溢出指的是内存中某一块区域的使用量超过了允许使用的最大值，从而使用内存时因空间不足而失败，虚拟机一般会抛出指定的错误。

在Java虚拟机中，**只有<u>程序计数器</u><font color=red>不会</font>出现内存溢出的情况**，因为每个线程的程序计数器只保存一个固定长度的地址。



- 堆内存溢出：
  
  > 堆内存溢出指的是在堆上分配的对象空间超过了堆的最大大小，从而导致的内存溢出。堆的最大大小使用-Xmx参数进行设置，如-Xmx10m代表最大堆内存大小为10m。溢出之后会抛出OutOfMemoryError，并提示是Java heap Space导致的

- 栈内存溢出：
  
  > 栈内存溢出指的是所有栈帧空间的占用内存超过了最大值，最大值使用-Xss进行设置，比如-Xss256k代表所有栈帧占用内存大小加起来不能超过256k。溢出之后会抛出StackOverflowError

- 方法区内存溢出：
  
  > 方法区内存溢出指的是方法区中存放的内容比如类的元信息超过了方法区内存的最大值，**JDK7及之前**版本方法区使用<u>永久代</u>（-XX:MaxPermSize=值）来实现，**JDK8及之后**使用<u>元空间</u>（-XX:MaxMetaspaceSize=值）来实现。

- 直接内存溢出：
  
  > 直接内存溢出指的是申请的直接内存空间大小超过了最大值，使用 -XX:MaxDirectMemorySize=值 设置最大值。溢出之后会抛出OutOfMemoryError
  
  

## JVM在JDK6-8之间在内存区域上有什么不同

1. 方法区的实现
   
    - JDK7及之前的版本将方法区存放在<font color=red>堆区域中的永久代空间</font>，堆的大小由虚拟机参数来控制。

    - JDK8及之后的版本将方法区存放在<font color=red>元空间</font>中，元空间位于操作系统维护的<font color=red>直接内存</font>中，默认情况下只要不超过操作系统承受的上限，可以一直分配。也可以手动设置最大大小。
     
    !!!question "使用元空间替换永久代的原因"
      
        - **提高内存上限**：元空间使用的是操作系统内存，而不是JVM内存。如果不设置上限，只要不超过操作系统内存上限，就可以持续分配。而永久代在堆中，可使用的内存上限是有限的。所以使用元空间可以有效减少OOM情况的出现。

        - **优化垃圾回收的策略**：永久代在堆上，垃圾回收机制一般使用老年代的垃圾回收方式，不够灵活。使用元空间之后单独设计了一套适合方法区的垃圾回收机制。

2. 字符串常量池的位置


字符串常量池从方法区移动到堆的原因：

1. **垃圾回收优化**：字符串常量池的回收逻辑和对象的回收逻辑类似，内存不足的情况下，如果字符串常量池中的常量不被使用就可以被回收；方法区中的类的元信息回收逻辑更复杂一些。移动到堆之后，就可以利用对象的垃圾回收器，对字符串常量池进行回收。

2. **让方法区大小更可控**：一般在项目中，类的元信息不会占用特别大的空间，所以会给方法区设置一个比较小的上限。如果字符串常量池在方法区中，会让方法区的空间大小变得不可控。

3. **intern方法的优化**：JDK6版本中intern () 方法会把第一次遇到的字符串实例复制到永久代的字符串常量池中。JDK7及之后版本中由于字符串常量池在堆上，就可以进行优化：字符串保存在堆上，把字符串的引用放入字符串常量池，减少了复制的操作。
   
   

## 类的生命周期


- [x] 加载

- [x] 连接（验证、准备、解析）

- [x] 初始化

- [x] 卸载

<br>

1. 加载
   
    - 加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。程序员可以使用Java代码拓展的不同的渠道。

    - 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。在方法区生成一个InstanceKlass对象，保存类的所有信息。

    - 在堆中生成一份与方法区中数据类似的java.lang.Class对象， 作用是在Java代码中去获取类的信息。

2. 连接
   
    - 验证
        
        - 验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。
        
        - 主要包含如下四部分，具体详见《Java虚拟机规范》：
        
            1. 文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。
            
            2. 元信息验证，例如类必须有父类（super不能为空）。
            
            3. 验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去。
            
            4. 符号引用验证，例如是否访问了其他类中private的方法等。

    - 准备
        
        - 准备阶段为静态变量（static）分配内存并设置初值。final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

    - 解析
        
        - 解析阶段主要是将常量池中的符号引用替换为直接引用。符号引用就是在字节码文件中使用编号来访问常量池中的内容。直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。

3. 初始化
   
    - 初始化阶段会执行静态代码块中的代码，并为静态变量赋值。

    - 初始化阶段会执行字节码文件中clinit部分的字节码指令。

4. 卸载

    判定一个类可以被卸载。需要同时满足下面三个条件：

    - 此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。

    - 加载该类的类加载器已经被回收。

    - 该类对应的java.lang.Class 对象没有在任何地方被引用
     
     
     
     

## 类加载器


- [x] 类加载器的作用

- [x] 启动类加载器

- [x] 扩展/平台类加载器

- [x] 应用程序类加载器

- [x] 自定义类加载器（可选）

<br>

1. 作用

    类加载器负责在类的加载过程中将字节码信息以流的方式获取并加载到内存中。

2. 启动类加载器
   
    - 启动类加载器（BootstrapClassLoader）是由Hotspot虚拟机提供的类加载器，JDK9之前使用C++编写的、JDK9之后使用Java编写。

    - 默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。

3. 扩展类加载器
   
    - 扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。JDK9之后由于采用了模块化，改名为Platform平台类加载器。

    - 默认加载Java安装目录/jre/lib/ext下的类文件。

4. 应用程序类加载器
   
    - 应用程序类加载器（Application Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载应用程序classpath下的类。

5. 自定义类加载器允许用户自行实现类加载的逻辑，可以从网络、数据库等来源加载类信息。自定义类加载器需要继承自ClassLoader抽象类，重写findClass方法。
   
   
   
   

## 双亲委派机制



- [x] 类加载器和父类加载器

- [x] 什么是双亲委派机制

- [x] 双亲委派机制的作用

<br>

1. 类加载器和父类加载器
   
    - 类加载有层级关系，上一级称之为下一级的父类加载器。

2. 双亲委派机制指的是
   
    - 当一个类加载器接收到加载类的任务时，会向上查找是否加载过，再由顶向下进行加载。

    - 每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。

    ![fcb51ebf-f093-4649-aa66-5cb977cbc257](./images/fcb51ebf-f093-4649-aa66-5cb977cbc257.png)

3. 作用
   
    - 保证类加载的安全性：通过双亲委派机制避免恶意代码替换JDK中的核心类库，确保核心类库的完整性和安全性。

    - 避免重复加载：双亲委派机制可以避免同一个类被多次加载。
     
     
     
     

## 打破双亲委派机制

ClassLoader中包含了4个核心方法，对Java程序员来说，打破双亲委派机制的唯一方法就是实现自定义类加载器重写loadClass方法，将其中的双亲委派机制代码去掉。

![0cb78987-1021-4f62-8f8b-de041917d909](./images/0cb78987-1021-4f62-8f8b-de041917d909.png)

![7c7f08ca-b797-40d6-a311-eae6357f50b4](./images/7c7f08ca-b797-40d6-a311-eae6357f50b4.png)



## Tomcat的自定义类加载器

Tomcat中，实现了一套自定义的类加载器。这一小节使用Tomcat9（9.0.84）源码进行分析。

![d852b58d-ede8-4d79-a2ea-c1b52eb2edd2](./images/d852b58d-ede8-4d79-a2ea-c1b52eb2edd2.png)



- common类加载器主要加载tomcat自身使用以及应用使用的jar包，默认配置在catalina.properties文件中。common.loader="\${catalina.base}/lib", "\${catalina.base}/lib/*.jar"

- catalina类加载器主要加载tomcat自身使用的jar包，不让应用使用，默认配置在catalina.properties文件中。server.loader= 默认配置为空，为空时catalina加载器和common加载器是同一个。

- shared类加载器主要加载应用使用的jar包，不让tomcat使用，默认配置在catalina.properties文件中。shared.loader= 默认配置为空，为空时shared加载器和common加载器是同一个。

- ParallelWebappClassLoader类加载器可以多线程并行加载应用中使用到的类，<font color=red>每个应用</font>都拥有一个自己的该类加载器。
  
    !!!question "为什么每个应用会拥有一个独立的ParallelWebappClassLoader类加载器呢"
        同一个类加载器，只能加载一个**同名的类**。如果两个应用中有相同名称的类都必须要加载。

- JasperLoader类加载器负责加载JSP文件编译出来的class字节码文件，为了实现**热部署**（不重启让修改的jsp生效），每一个jsp文件都由一个独立的JasperLoader负责加载。
  
  

ParallelWebappClassLoader的执行流程：

!!!note 
    这里打破了双亲委派机制，应用中的类如果没有加载过。会先从当前类加载器加载，然后再交给父类加载器通过双亲委派机制加载。

![8edb3355-70c6-4247-9b6f-68bfa54efd19](./images/8edb3355-70c6-4247-9b6f-68bfa54efd19.png)





## 如何判断堆上的对象没有被引用？


- [x] 引用计数法

- [x] 可达性分析法

- [x] 使用可达性分析法原因
  
<br>

常见的有两种判断方法：**引用计数法**和**可达性分析法**。

引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。



引用计数法的优点是实现简单，缺点有两点：

1. 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响

2. 存在**循环引用**问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。
   
   
<br>
   

Java中使用的是<font color=red>可达性分析算法</font>来判断对象是否可以被回收。

可达性分析将对象分为两类：垃圾回收的**根对象GC Root**和普通对象，对象与对象之间存在引用关系。

可达性分析算法指的是如果从某个对象到GC Root对象是可达的，对象就不可被回收。



!!!question "哪些对象被称之为GC Root对象呢？"

    - 线程Thread对象，引用线程栈帧中的方法参数、局部变量等。

    - 系统类加载器加载的java.lang.Class对象，引用类中的静态变量。

    - 监视器对象，用来保存同步锁synchronized关键字持有的对象。

    - 本地方法调用时使用的全局对象。
  
  
  
  

## JVM 中都有哪些引用类型

- [x] 强引用

- [x] 软引用

- [x] 弱引用

- [ ] 虚引用

- [ ] 终结器引用
  
<br>

- **强引用**，JVM中默认引用关系就是强引用，即是对象被局部变量、静态变量等GC Root关联的对象引用，只要这层关系存在，普通对象就不会被回收。

- **软引用**，软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。软引用主要在缓存框架中使用。

- **弱引用**，弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收，弱引用主要在ThreadLocal中使用。

- **虚引用**（幽灵引用/幻影引用），不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。

- **终结器引用**，终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。
  
  
  
  

## ThreadLocal中为什么要使用弱引用

ThreadLocal可以在线程中存放线程的本地变量，保证数据的线程安全。



ThreadLocal中是这样保存对象的：

1. 在每个线程中，存放了一个<font color=red>ThreadLocalMap对象</font>，本质上就是一个数组实现的哈希表，里面存放多个Entry对象。

2. 每个Entry对象继承自**弱引用**，内部存放ThreadLocal对象。同时用强引用，引用保存ThreadLocal对应的value值。

![904183c1-c4bc-4a78-97ff-2684a07b293d](./images/904183c1-c4bc-4a78-97ff-2684a07b293d.png)

不再使用Threadlocal对象时， threadlocal = null；由于是弱引用，那么在垃圾回收之后，**ThreadLocal对象就可以被回收**。

> 此时还有Entry对象和value对象没有能被回收，所以在ThreadLocal类的set、get、remove方法中，在某些特定条件满足的情况下，会主动删除这两个对象。
> 
> 如果一直不调用set、get、remove方法或者调用了没有满足条件，这部分对象就会出现内存泄漏。**强烈建议**在ThreadLocal不再使用时，<font color=red>调用remove方法</font>回收将Entry对象的引用关系去掉，这样就可以回收这两个对象了。



## 常见的垃圾回收算法

垃圾回收算法的机制、优缺点

- [x] 标记清除

- [x] 标记整理

- [x] 复制

- [x] 分代GC

<br>

1. 标记清除算法

    标记清除算法的核心思想分为两个阶段：

    - 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。

    - 清除阶段，从内存中删除没有被标记也就是非存活对象。
   
    > 优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。
    > 缺点：
    > 
    > - 碎片化问题。由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。
    > 
    > - 分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。

2. 复制算法

    复制算法的核心思想是：

    - 准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。

    - 在垃圾回收GC阶段，将From中存活对象复制到To空间。

    - 将两块空间的From和To名字互换。

    > 优点：
    > 
    > - 吞吐量高。复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动
    > 
    > - 不会发生碎片化。复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。
    > 
    > 缺点：内存使用效率低。每次只能让一半的内存空间来为创建对象使用

3. 标记整理算法

    标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。核心思想分为两个阶段：

    - 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。

    - 整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。

    > 优点：
    > 
    > - 内存使用效率高。整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
    > 
    > - 不会发生碎片化。在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间
    > 
    > 缺点：整理阶段的效率不高。整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过TwoFinger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能

4. 分代GC算法
    现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法(Generational GC)。分代垃圾回收将整个内存区域划分为**年轻代**和**老年代**。

    - 分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。

    - 随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。Minor GC会把eden中和From需要回收的对象回收，把没有回收的对象放入To区。

    - 接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。
        
        > 注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。

    - 如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。

    - 当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。
        
        > 如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。

    优点：

    1. 可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。

    2. 新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法效率高、不会产生内存碎片，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。

    3. 分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW（Stop The World）由垃圾回收引起的停顿时间就会减少。
   
   

## 常见的垃圾回收器


- [x] Serial垃圾回收器 + SerialOld垃圾回收器

- [x] ParNew+ CMS 

- [x] PS+PO

- [x] G1

- [x] Shenandoah 和 ZGC
  
<br>

1. Serial

![d6eb90aa-3e06-47ea-9631-6e13dd2eb6d5](./images/d6eb90aa-3e06-47ea-9631-6e13dd2eb6d5.png)



2. Parallel

![deb62f27-a32d-4622-9939-8168c373b3c4](./images/deb62f27-a32d-4622-9939-8168c373b3c4.png)



3. ParNew+CMS


CMS垃圾回收器存在的问题

1. CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之后再整理。

2. 无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。

3. 如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。

4. 并发阶段会影响用户线程执行的性能
   
<br>  

5. G1

![6be34609-5a30-45ec-a193-00d098279cc3](./images/6be34609-5a30-45ec-a193-00d098279cc3.png)





6. Shenandoah 是由Red Hat开发的一款低延迟的垃圾收集器，Shenandoah 并发执行大部分 GC 工作，包括并发的整理，堆大小对STW的时间基本没有影响。



7. ZGC 是一种可扩展的低延迟垃圾回收器。ZGC 在垃圾回收过程中，STW的时间不会超过一毫秒，适合需要低延迟的应用。支持几百兆到16TB 的堆大小，堆大小对STW的时间基本没有影响。



如何选择垃圾回收器，请跳转至”基础篇“【垃圾回收器】小节



## 如何解决内存泄漏问题



- [x] 内存溢出和内存泄漏

- [x] 解决内存泄漏问题的思路

- [x] 常用的工具
  
<br>

- **内存泄漏**（memory leak）：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏。

- 少量的内存泄漏可以容忍，但是如果发生**持续的内存泄漏**，就像滚雪球雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是**内存溢出**。

![204e3551-72af-41f4-9523-f96770f0ff89](./images/204e3551-72af-41f4-9523-f96770f0ff89.png)


> 生产环境通过运维提供的Prometheus + Grafana 等监控平台查看
> 
> 开发、测试环境通过visualvm查看



<font color=red>诊断–生成内存快照</font>

当堆内存溢出时，需要在堆内存溢出时将整个堆内存保存下来，生成内存快照(Heap Profile)文件。生成方式有两种

1. 内存溢出时自动生成，添加生成内存快照的Java虚拟机参数：`-XX:+HeapDumpOnOutOfMemoryError`：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。`-XX:HeapDumpPath=<path>`：指定hprof文件的输出路径。

2. 导出运行中系统的内存快照，比较简单的方式有两种，注意只需要导出标记为存活的对象：
   通过JDK自带的jmap命令导出，格式为：`jmap-dump:live,format=b,file=文件路径和文件名 进程ID`
   通过arthas的heapdump命令导出，格式为：`heapdump--live 文件路径和文件名`
   
   

<font color=red>诊断–MAT定位问题</font>

使用MAT打开hprof文件，并选择内存泄漏检测功能，MAT会自行根据内存快照中保存的数据分析内存泄漏的根源。



![80c1cce4-6c3c-4924-add2-6bcf2079fc76](./images/80c1cce4-6c3c-4924-add2-6bcf2079fc76.png)



## 常见的JVM参数


- [x] 最大堆内存参数

- [x] 最大栈内存参数

- [x] 最大元空间内存参数

- [x] 日志参数

- [x] 堆内存快照参数

- [ ] 垃圾回收器参数

- [ ] 垃圾回收器调优参数
  
<br>  

- 参数1 ： `-Xmx` 和 `–Xms`    最大、最小堆内存
  <font color=red>最合理的设置方式应该是根据最大并发量估算服务器的配置，然后再根据服务器配置计算最大堆内存的值。</font>
  建议将-Xms设置的和-Xmx一样大,运行过程中不再产生扩容的开销。
  
  

- 参数2 ： `-XX:MaxMetaspaceSize` 和 `-Xss`    最大元空间大小、栈大小
  -XX:MaxMetaspaceSize=值 参数指的是最大元空间大小，默认值比较大，如果出现元空间内存泄漏会让操作系统可用内存不可控，建议根据测试情况设置最大值，一般设置为256m。
  -Xss256k 栈内存大小，如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。比如Linux x86 64位 ： 1MB，如果不需要用到这么大的栈内存，完全可以将此值调小节省内存空间，合理值为256k – 1m之间。
  
  

- 参数3：    `-Xmn`    年轻代的大小
  默认值为整个堆的1/3，可以根据峰值流量计算最大的年轻代大小，尽量让对象只存放在年轻代，不进入老年代。但是实际的场景中，接口的响应时间、创建对象的大小、程序内部还会有一些定时任务等不确定因素都会导致这个值的大小并不能仅凭计算得出，如果设置该值要进行大量的测试。
  <font color=red>G1垃圾回收器尽量不要设置该值，G1会动态调整年轻代的大小。</font>
  
  

- 打印GC日志
  JDK8及之前 ： `-XX:+PrintGCDetails` `-XX:+PrintGCDateStamps-Xloggc:文件路径`
  JDK9及之后 ： `-Xlog:gc*:file=文件路径`
  
  

- `-XX:+DisableExplicitGC`禁止在代码中使用System.gc()， System.gc()可能会引起FULLGC，在代码中尽量不要使用。使用DisableExplicitGC参数可以禁止使用System.gc()方法调用。
  
  

- `-XX:+HeapDumpOnOutOfMemoryError`：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。`-XX:HeapDumpPath=<path>`指定hprof文件的输出路径。
  
  

JVM参数模板

```powershell
-Xms1g
-Xmx1g
-Xss256k
-XX:MaxMetaspaceSize=512m 
-XX:+DisableExplicitGC
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/opt/logs/my-service.hprof
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:文件路径
```

> 注意：JDK9及之后gc日志输出修改为 -Xlog:gc*:file=文件名
> 
> 堆内存大小和栈内存大小根据实际情况灵活调整。


---
**上一节**：[JVM 原理](JVM-principle.md)

**完**

