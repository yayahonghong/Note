# 代理

代理（Proxy）是 Java 中一种重要的设计模式，用于在不修改原始类代码的情况下增强或控制对象的行为。

Java 提供了多种代理实现方式，主要分为 **静态代理** 和 **动态代理**（JDK 动态代理、CGLIB 动态代理）。

<br>

## 静态代理

**特点**

- **手动编写代理类**，在编译时确定代理关系
- **代理类和目标类实现相同接口**
- **简单直接**，但每个目标类需要一个代理类

**示例**

```java
// 1. 定义接口
interface UserService {
    void save();
}

// 2. 目标类
class UserServiceImpl implements UserService {
    public void save() {
        System.out.println("保存用户");
    }
}

// 3. 静态代理类
class UserServiceProxy implements UserService {
    private UserService target;

    public UserServiceProxy(UserService target) {
        this.target = target;
    }

    public void save() {
        System.out.println("前置增强");
        target.save(); // 调用目标方法
        System.out.println("后置增强");
    }
}

// 4. 使用
public class Main {
    public static void main(String[] args) {
        UserService target = new UserServiceImpl();
        UserService proxy = new UserServiceProxy(target);
        proxy.save();
    }
}
```



|    优点    |            缺点            |
| :--------: | :------------------------: |
|  实现简单  |  每个目标类需要一个代理类  |
| 无额外依赖 | 接口修改时需同步修改代理类 |


<br>

## 动态代理

### JDK动态代理

**特点**

- **基于接口**（要求目标类必须实现接口）
- 通过 `java.lang.reflect.Proxy` 和 `InvocationHandler` 实现
- **运行时生成代理类**

**示例**

```java
// 1. 定义接口和目标类（同上）

// 2. 实现 InvocationHandler
class LogHandler implements InvocationHandler {
    private Object target;

    public LogHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("方法调用前: " + method.getName());
        Object result = method.invoke(target, args); // 反射调用目标方法
        System.out.println("方法调用后");
        return result;
    }
}

// 3. 使用 Proxy 创建代理对象
public class Main {
    public static void main(String[] args) {
        UserService target = new UserServiceImpl();
        UserService proxy = (UserService) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new LogHandler(target)
        );
        proxy.save();
    }
}
```

**实现原理**

1. 运行时生成代理类（类名格式：`$Proxy0`）
2. 代理类继承 `Proxy` 并实现目标接口
3. 方法调用转发给 `InvocationHandler.invoke()`

<br>

### CGLIB动态代理

**特点**

- **基于继承**（可代理无接口的类）
- 通过 ASM 字节码框架生成子类
- 需要引入 `cglib` 依赖

**示例**

```java
// 1. 目标类（无需接口）
class UserService {
    public void save() {
        System.out.println("保存用户");
    }
}

// 2. 实现 MethodInterceptor
class LogInterceptor implements MethodInterceptor {
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("方法调用前: " + method.getName());
        Object result = proxy.invokeSuper(obj, args); // 调用父类方法
        System.out.println("方法调用后");
        return result;
    }
}

// 3. 使用 Enhancer 创建代理
public class Main {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class); // 设置父类
        enhancer.setCallback(new LogInterceptor()); // 设置回调
        UserService proxy = (UserService) enhancer.create(); // 创建代理
        proxy.save();
    }
}
```

**实现原理**

1. 生成目标类的子类（如 `UserService$$EnhancerByCGLIB$$xxxx`）
2. 重写父类方法，加入拦截逻辑

<br>

## 对比

|       特性       |   静态代理   |   JDK 动态代理   |  CGLIB 动态代理  |
| :--------------: | :----------: | :--------------: | :--------------: |
| **是否需要接口** |     需要     |       需要       |      不需要      |
|   **生成方式**   |   手动编写   |  运行时动态生成  |  运行时动态生成  |
|     **性能**     |      高      | 中等（反射调用） | 高（ASM 字节码） |
|     **依赖**     |      无      |     JDK 自带     |  需引入 `cglib`  |
|   **适用场景**   | 简单少量代理 |  基于接口的代理  |  无接口的类代理  |



## 应用场景

1. **AOP 编程**（如 Spring AOP）
2. **远程方法调用**（RPC 框架）
3. **事务管理**
4. **日志记录**
5. **权限控制**

---

**完**
