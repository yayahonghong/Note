# 函数式编程

Java 8 引入了函数式编程的支持，主要通过 **Lambda 表达式**、**函数式接口**、**Stream API** 和 **方法引用** 等特性来实现。以下是 Java 函数式编程的核心知识点：

---

### 1.Lambda 表达式
Lambda 表达式是函数式编程的核心特性之一，它允许将函数作为方法参数传递，简化了匿名内部类的写法。

**语法：**

```java
(parameters) -> expression
(parameters) -> { statements; }
```

**示例：**

```java
// 传统匿名内部类
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello World");
    }
};

// 使用 Lambda 表达式
Runnable r2 = () -> System.out.println("Hello World");
```

<br>

---

### 2.函数式接口（Functional Interface）
函数式接口是只包含一个抽象方法的接口。Java 8 提供了 `@FunctionalInterface` 注解来标识函数式接口。

**常见的函数式接口：**

- `Runnable`：`void run()`
- `Supplier<T>`：`T get()`
- `Consumer<T>`：`void accept(T t)`
- `Function<T, R>`：`R apply(T t)`
- `Predicate<T>`：`boolean test(T t)`

**示例：**
```java
@FunctionalInterface
interface MyFunctionalInterface {
    void doSomething();
}

MyFunctionalInterface func = () -> System.out.println("Doing something");
func.doSomething();
```

<br>

---

### 3.Stream API

Java Stream 流是 Java 8 引入的一个新的抽象层，用于处理序列（如集合）中的元素。Stream 流允许你以声明性的方式处理数据，支持诸如**过滤、映射、排序、聚合和查找**等操作，并且可以方便地进行并行处理


**核心操作：**

- **中间操作**：`filter`, `map`, `sorted`, `distinct` 等。
- **终端操作**：`forEach`, `collect`, `reduce`, `count` 等。


**流的使用步骤**：

1. **创建流**：可以通过集合（如 List、Set）、数组、生成器或特定的方法来创建流。

    - 例如：`List<String> list = Arrays.asList("a", "b", "c"); Stream<String> stream = list.stream();`

    - **单列集合**如`ArrayList`、`LinkedList`可以直接使用`Collection`中的默认方法`stream()`获得流

    - **双列集合**如`HashMap`无法直接使用流，需要通过`keySet()`方法或`entrySet()`方法得到单列集合

    - **数组**可以使用`Arrays`工具类中的静态方法获得流

     

2. **中间操作**：这些操作会返回一个**新的流**，允许你进行一系列的操作。

    - 常见的中间操作有：`filter()`（过滤）、`map()`（映射）、`sorted()`（排序）、`distinct()`（去重）等。

     

3. **终端操作**：这些操作会结束流的流水线并返回一个结果（如一个值，一个集合，或者不返回任何值，如执行某些操作）。

    - 常见的终端操作有：`forEach()`（对每个元素执行操作）、`collect()`（收集结果）、`reduce()`（归约）、`count()`（计数）、`anyMatch()`（匹配任意元素）、`allMatch()`（匹配所有元素）、`noneMatch()`（不匹配任何元素）等。


**示例：**

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 过滤并打印长度大于 3 的名字
names.stream()
     .filter(name -> name.length() > 3)
     .forEach(System.out::println);

// 将名字转换为大写并收集到列表
List<String> upperCaseNames = names.stream()
                                   .map(String::toUpperCase)
                                   .collect(Collectors.toList());
```

<br>

---

### 4. 并行流（Parallel Stream）
Java 8 的 Stream API 支持并行处理数据，可以充分利用多核 CPU 的优势。

**示例：**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 并行处理
long count = names.parallelStream()
                  .filter(name -> name.length() > 3)
                  .count();
```

<br>

---

### 5.方法引用（Method Reference）
方法引用是 Lambda 表达式的一种简化写法，用于直接引用已有的方法。

**四种方法引用形式：**
1. 静态方法引用：`ClassName::staticMethod`
2. 实例方法引用：`instance::method`
3. 类的任意对象的实例方法引用：`ClassName::method`
4. 构造方法引用：`ClassName::new`

**示例：**

```java
// Lambda 表达式
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println(name));

// 方法引用
names.forEach(System.out::println);
```

<br>

---

### 6.Optional 类
`Optional` 是 Java 8 引入的用于解决 `null` 问题的容器类。它可以避免空指针异常，并提供函数式编程风格的操作。

**常用方法：**
- `of`, `ofNullable`, `empty`
- `isPresent`, `ifPresent`
- `orElse`, `orElseGet`, `orElseThrow`
- `map`, `flatMap`, `filter`

**示例：**
```java
Optional<String> name = Optional.ofNullable(getName());
name.ifPresent(System.out::println);

String result = name.orElse("Default Name");
```

<br>

---

### 7.高阶函数
高阶函数是指接受函数作为参数或返回函数的函数。Java 中可以通过函数式接口实现高阶函数。

**示例：**

```java
public static <T> List<T> filterList(List<T> list, Predicate<T> predicate) {
    return list.stream()
               .filter(predicate)
               .collect(Collectors.toList());
}

List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> filteredNames = filterList(names, name -> name.startsWith("A"));
```

<br>

---

### 8.函数式编程的优势
- **简洁性**：代码更简洁易读。
- **不可变性**：强调不可变对象和纯函数，减少副作用。
- **并行处理**：Stream API 支持并行处理，提升性能。
- **组合性**：函数可以组合使用，提高代码复用性。

<br>

---

### 9.注意事项
- **性能开销**：Lambda 表达式和 Stream API 在某些场景下可能带来性能开销。
- **调试困难**：Lambda 表达式的调试不如传统代码直观。
- **滥用问题**：过度使用函数式编程可能导致代码可读性下降。

---

**完**
