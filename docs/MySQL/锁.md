
### 概述

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）以外，数据也是一种供许多用户共享的资源。



MySQL中的锁，按照锁的粒度分，分为以下三类： 

- 全局锁：锁定数据库中的所有表。 
- 表级锁：每次操作锁住整张表。 
- 行级锁：每次操作锁住对应的行数据。

<br>

### 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被**阻塞**。



其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

!!!warning
    不加全局锁的情况下备份可能发生的数据不一致问题

![image-20250430092848545](./images/image-20250430092848545.png)


```sql
-- 加全局锁
flush tables with read lock;

-- 逻辑备份
mysqldump  -uroot –p******  database_name > database_backup.sql;

-- 释放锁
unlock tables;
```



加上全局锁，很多业务都会阻塞，在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。

```sql
mysqldump --single-transaction -uroot –p******  database_name > database_backup.sql;
```

!!!note
    该命令会启动一个事务并设置隔离级别为`REPEATABLE READ`，通过`START TRANSACTION WITH CONSISTENT SNAPSHOT`创建一致性视图。备份过程中读取的都是事务开始时的一致性数据快照，不受其他并发事务修改的影响

<br>

### 表级锁

有三类表级锁：

- 表锁 
- 元数据锁（meta data lock，MDL） 
- 意向锁



---

1.表锁又有两种：

- 表**共享读锁**（多客户端读）
- 表**独占写锁**（单客户端读写）

```sql
-- 加锁
lock tables table_name read/write;

-- 释放锁
unlock tables;
```

!!!note
    读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。



---

2.元数据锁（MDL）加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。

MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。**为了避免DML与 DDL冲突，保证读写的正确性。**

|       操作类型       |  MDL锁类型   |   阻塞关系    |
| :------------------: | :----------: | :-----------: |
|      SELECT查询      | SHARED_READ  | 不阻塞其他DML |
| INSERT/UPDATE/DELETE | SHARED_WRITE | 不阻塞其他DML |
|   DDL操作(ALTER等)   |  EXCLUSIVE   | 阻塞所有操作  |
|    手动锁表(READ)    |    SHARED    |    阻塞DDL    |
|   手动锁表(WRITE)    |  EXCLUSIVE   | 阻塞所有操作  |



---

3.为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁

!!!tip
    假如没有意向锁，客户端一对表加了行锁后，客户端二会检查当前表是否有对应的行锁（逐行遍历，效率低），如果没有，则添加表锁

客户端在执行DML操作时，会对涉及的行加行锁，**同时也会对该表加上意向锁**，而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁



- 意向共享锁(IS): 由语句select ... lock in share mode添加。与表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。 
- 意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。


<br>


### 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 **InnoDB存储引擎**中。

InnoDB的数据是基于索引组织的，行锁是通过对索引上的**索引项加锁**来实现的，而不是对记录加的锁。



- 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。
- 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。
- 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。



---

1.行锁

共享锁（S）：允许一个事务读，阻止其他事务获得相同数据集的排它锁。 

排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

|      | S    | X    |
| ---- | ---- | ---- |
| S    | 兼容 | 冲突 |
| X    | 冲突 | 冲突 |



加锁情况

|              SQL              | 类型 | 加锁方式 |
| :---------------------------: | :--: | :------: |
|            insert             |  X   |   自动   |
|            update             |  X   |   自动   |
|            delete             |  X   |   自动   |
|           select...           |  -   |    -     |
| select ... lock in share mode |  S   |   手动   |
|     select ... for update     |  X   |   手动   |

!!!warning
    如果where条件里的字段不是索引项，行锁会升级为表锁



---

2.间隙锁&临键锁

- 索引上的等值查询(唯一索引)，给**不存在的记录加锁**时, 优化为间隙锁 。 
- 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key  lock 退化为间隙锁。 
- 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。

!!!note
    间隙锁的唯一目是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。

