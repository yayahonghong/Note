
## 共享模型-内存

### 可见性

退不出的循环

```java
    static boolean run = true;

    public static void main(String[] args) {

        new Thread(() -> {
            while (run) {
                // do something
            }
        }).start();

        log.info("stop thread");
        run = false;

    }
```

>[!Caution]
>
>以上线程并不会在`run`的值改变后退出



原因如下：

![image-20250409150006920](./images/image-20250409150006920.png)

1. **JMM的可见性问题**：
   - 在Java内存模型中，每个线程有自己的工作内存(缓存)
   - `run`变量是普通变量(非volatile)，修改可能不会立即对其他线程可见
   - 主线程修改`run=false`后，子线程可能仍然读取的是自己工作内存中的旧值`true`
2. **编译器/JIT优化**：
   - JIT编译器可能会将`while(run)`优化为`while(true)`，因为循环体内没有操作
   - 这种优化称为"循环提升"(Loop Hoisting)



**解决方案**

1. 使用volatile关键字(推荐)

```java
static volatile boolean run = true;
```

`volatile`保证：

- 可见性：修改立即对其他线程可见
- 有序性：禁止指令重排序



2. 使用synchronized同步

```java
static boolean run = true;
static final Object lock = new Object();

// 写操作
synchronized(lock) {
    run = false;
}

// 读操作
synchronized(lock) {
    while(run) { ... }
}
```



#### 两阶段终止模式

可以使用`volatile`实现该模式



#### Balking模式

Balking模式是一种**多线程设计模式**，用于在对象处于不适当状态时立即放弃当前操作，而不是等待状态变为可用状态。



典型场景

1. 文件自动保存功能（如果已经保存过则不再重复保存）
2. 服务初始化（只初始化一次）
3. 网络请求取消（如果已经开始处理则不接受取消）
4. 线程启动检查（如果线程已在运行则不重复启动）



```java
class VolatileBalking {
    private volatile boolean initialized = false;
    
    public void init() {
        if (initialized) {
            return;
        }
        synchronized (this) {
            if (initialized) { // 双重检查
                return;
            }
            doInit();
            initialized = true;
        }
    }
    
    private void doInit() {
        // 初始化逻辑
    }
}
```



例：线程安全的单例模式

```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {                  // 第一次检查：Balking，直接返回避免同步，优化性能
            synchronized (Singleton.class) {      // 同步
                if (instance == null) {          // 第二次检查：线程安全
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```



### 有序性

**指令重排**：在**不改变单线程程序语义**的前提下，编译器、运行时或处理器可能会改变代码的执行顺序

> 指令重排，这个现象需要通过**大量**测试才能复现（ java 并发压测工具 jcstress）

 

示例

```java
    boolean ready = false;
	int num = 0;
    // 线程1 执行此方法
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        }
        else {
            r.r1 = 1;
        }
    }
    // 线程2 执行此方法
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
```

> [!Tip]
>
> 以上代码，`r.r1`的值可能是1，4，**0**
>
> 其中0是指令重排序的结果



- 禁止重排序：
  - 在volatile写之前的所有操作不会被重排序到写之后
  - 在volatile读之后的所有操作不会被重排序到读之前



> [!Caution]
>
> `synchronized` 是不能阻止指令重排的



#### volatile

内存屏障是处理器提供的一组特殊指令，用于控制指令执行顺序和内存可见性，在多线程编程中至关重要。读屏障和写屏障是两种基本的内存屏障类型。

##### 读屏障

- 确保屏障后的**读操作**不会重排序到屏障前
- 强制从主内存（而非缓存）重新加载数据

##### 写屏障

- 确保屏障前的**写操作**不会重排序到屏障后
- 强制将写缓冲区内容刷入主内存



#####  double-checked locking 问题

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) { // t2
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

字节码

```java
0: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull     37
6: ldc           #3                  // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter
11: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull     27
17: new           #3                  // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4                  // Method "<init>":()V
24: putstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto          37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
```

其中 

17 表示创建对象，将对象引用入栈  // new Singleton 

20 表示复制一份对象引用  // 引用地址 

21 表示利用一个对象引用，调用构造方法  

24 表示利用一个对象引用，赋值给 static INSTANCE 

也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：

![image-20250409164312112](./images/image-20250409164312112.png)

关键在于 

0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例 

**对 INSTANCE 使用 volatile 修饰即可**，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效



读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence））

- 可见性
  - 写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中 
  - 而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据 
- 有序性
  - 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 
  - 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

- 更底层是读写变量时使用 lock 指令来实现多核 CPU 之间的可见性与有序性



#### happens-before

happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛 开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见

1. 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见

```java
        static int x;
        static Object m = new Object();
        new Thread(() -> {
            synchronized (m) {
                x = 10;
            }
        }, "t1").start();
        new Thread(() -> {
            synchronized (m) {
                System.out.println(x);
            }
        }, "t2").start();
```

2. 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

```java
        volatile static int x;
        new Thread(()->{
            x = 10;
        },"t1").start();
        new Thread(()->{
            System.out.println(x);
        },"t2").start();
```

3. 线程 start 前对变量的写，对该线程开始后对该变量的读可见

```java
        static int x;
        x = 10;
        new Thread(()->{
            System.out.println(x);
        },"t2").start();
```

4. 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）

```java
        static int x;
        Thread t1 = new Thread(()->{
            x = 10;
        },"t1");
        t1.start();
        t1.join();
        System.out.println(x);
```

5. 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）

```java
        static int x;

        Thread t2 = new Thread(()->{
            while(true) {
                if(Thread.currentThread().isInterrupted()) {
                    System.out.println(x);
                    break;
                }
            }
        },"t2");
        t2.start();
        new Thread(()->{
            sleep(1);
            x = 10;
            t2.interrupt();
        },"t1").start();

        while(!t2.isInterrupted()) {
            Thread.yield();
        }
        System.out.println(x);
```

6. 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见
7. 具有传递性，如果  x hb-> y 并且  y hb-> z 那么有  x hb-> z ，配合 volatile 的防指令重排

```java
        volatile static int x;
        static int y;
        new Thread(()->{
            y = 10;
            x = 20;
        },"t1").start();
        new Thread(()->{
            // x=20 对 t2 可见, 同时 y=10 也对 t2 可见
            System.out.println(x);
        },"t2").start();
```



### 单例模式实现

> [!Tip]
>
> 以下实现均为线程安全

- 饿汉式

```java
public final class Singleton {
    private Singleton(){}
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```



- 双重检查

```java
public final class Singleton implements Serializable {
    private Singleton() {}
    private volatile static Singleton INSTANCE = null;
    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            // 可能有多个线程到达该分支
            synchronized (Singleton.class) {
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
    
    // 防止反序列化重新创建对象
    public Object readResolve() {
        return INSTANCE;
    }
}
```



- 枚举

```java
enum Singleton {
    INSTANCE;
}
```



- 静态内部类

```java
final class Singleton {
    // 私有构造函数，防止外部实例化
    private Singleton() {
        
    }
    
    // 静态内部类，用于延迟初始化单例实例
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    // 提供全局访问点，返回单例实例
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```



## 共享模型-无锁

### 无锁引例

```java
class AccountWithoutLock {
    private final AtomicInteger balance;

    public AccountWithoutLock(int balance) {
        this.balance = new AtomicInteger(balance);
    }
                                
    public int getBalance() {
        return balance.get();
    }

    public void withdraw(int amount) {
        while (true) {
            int prev = balance.get();
            int next = prev - amount;
            if (balance.compareAndSet(prev, next)) {
                break;
            }
        }
    }
}
```

> [!Note]
>
> 该类并没有使用**锁**技术
>
> 但是该类是线程安全的



其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。

![image-20250410163930267](./images/image-20250410163930267.png)



### CAS 和 volatile

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。

```java
    private volatile int value;

    public final int get() {
        return value;
    }
```

> [!Important]
>
> CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果



#### 无锁效率更高

- 无锁情况下，即使重试失败，线程始终在高速运行，不会阻塞，而 synchronized 会让线程在没有获得锁的时 候，发生**上下文切换**，进入**阻塞**。



- 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。



> [!Caution]
>
> **高竞争情况**：CAS可能因持续重试导致CPU资源浪费，此时锁可能更合适



#### CAS 特点

结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。

- CAS 是基于**乐观锁**的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，自己再重试
- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量



### 原子整数

> [!Note]
>
> `AtomicBoolean`
>
> `AtomicInteger`
>
> `AtomicLong`



相关API

```java
        AtomicInteger i = new AtomicInteger(0);

        // CAS操作
        i.compareAndSet(0, 1);


        i.incrementAndGet();// 自增1再获取
        i.getAndIncrement();// 获取再自增1

        // 自减1类似
        ...

        i.addAndGet(10);// 自增指定值再获取

        i.updateAndGet(x -> x * 100);// 函数式接口，更加灵活
```

> [!Tip]
>
> 这些API都是基于`compareAndSet`来实现的



### 原子引用

> [!Note]
>
> Java提供了一系列原子引用类，用于在多线程环境下安全地更新对象引用。这些类基于 **CAS（Compare-And-Swap）** 机制，保证原子性操作，避免使用锁带来的性能开销。
>
> `AtomicReference`
>
> `AtomicMarkableReference`
>
> `AtomicStampedReference`

---

Java中的原子引用类位于 `java.util.concurrent.atomic` 包，主要包括：

| 类                           | 说明                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| `AtomicReference<V>`         | 普通原子引用，可原子更新对象引用                             |
| `AtomicStampedReference<V>`  | 带版本号的原子引用，解决 **ABA问题**                         |
| `AtomicMarkableReference<V>` | 带标记位的原子引用（类似 `AtomicStampedReference`，但用布尔值标记） |

---

```java
class DecimalAccount {
    private final AtomicReference<BigDecimal> balance;

    DecimalAccount(BigDecimal balance) {
        this.balance = new AtomicReference<>(balance);
    }

    public BigDecimal getBalance() {
        return balance.get();
    }

    public void withdraw(BigDecimal amount) {
        BigDecimal prev, next;
        do {
            prev = balance.get();
            next = prev.subtract(amount);
        } while (!balance.compareAndSet(prev, next));
    }
}
```



#### ABA 问题

> [!Tip]
>
> ABA问题是 **CAS（Compare-And-Swap）** 操作中的一个经典并发问题，它可能导致程序逻辑错误，即使CAS操作成功，但实际数据可能已经被其他线程修改过多次。

ABA问题是指：

- 线程 **A** 读取共享变量的值为 **A**。
- 线程 **B** 在此期间修改该变量的值 **A → B → A**（即先改成B，又改回A）。
- 线程 **A** 执行CAS操作时，发现值仍然是 **A**，于是认为没有被修改过，从而CAS成功。但实际上，变量已经被修改过（B→A），可能导致逻辑错误。



**解决方案：版本号/时间戳（Stamped Reference）**

- 每次修改共享变量时，**增加一个版本号**（或时间戳）。
- CAS不仅要比较**值**，还要比较**版本号**。
- Java中的 `AtomicStampedReference` 就是基于此实现。

```java
AtomicStampedReference<Integer> atomicRef = new AtomicStampedReference<>(100, 0); // 初始值=100，版本号=0

int stampHolder = atomicRef.getStamp();
int currentValue = atomicRef.getReference; // 获取值和版本号
int newValue = currentValue + 1;
boolean success = atomicRef.compareAndSet(currentValue, newValue, stampHolder, stampHolder + 1);
```



### 原子数组

> [!Note]
>
> Java提供了一系列原子数组类，用于在多线程环境下安全地操作数组元素，而无需使用显式锁。这些类基于 **CAS（Compare-And-Swap）** 机制，保证对数组元素的原子性操作。

---

| 类                        | 说明                                 |
| :------------------------ | :----------------------------------- |
| `AtomicIntegerArray`      | 原子整型数组，可原子更新 `int[]`     |
| `AtomicLongArray`         | 原子长整型数组，可原子更新 `long[]`  |
| `AtomicReferenceArray<E>` | 原子引用数组，可原子更新对象引用数组 |

---

```java
// 初始化一个长度为 5 的原子整型数组
        AtomicIntegerArray atomicArray = new AtomicIntegerArray(5);

        // 多个线程并发修改数组
        Runnable task = () -> {
            for (int i = 0; i < atomicArray.length(); i++) {
                atomicArray.incrementAndGet(i); // 原子递增
            }
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 输出最终数组
        for (int i = 0; i < atomicArray.length(); i++) {
            System.out.println("Index " + i + ": " + atomicArray.get(i));
        }
```



### 原子更新器

> [!Note]
>
> 原子更新器是Java提供的一种高效的无锁原子操作方式，它允许对 **已有的普通类** 的 `volatile` 字段进行原子更新，而无需将整个类改为原子类。适用于当某个类的某个字段需要原子操作，但又不希望使用 `AtomicInteger`、`AtomicReference` 等包装类时。

---

| 类                                 | 说明                     |
| :--------------------------------- | :----------------------- |
| `AtomicIntegerFieldUpdater<T>`     | 原子更新 `int` 类型字段  |
| `AtomicLongFieldUpdater<T>`        | 原子更新 `long` 类型字段 |
| `AtomicReferenceFieldUpdater<T,V>` | 原子更新对象引用字段     |

---

```java
class Student {
    volatile String name;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}

Student student = new Student();
student.name = "Tom";
AtomicReferenceFieldUpdater<Student, String> updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");
updater.compareAndSet(student, "Tom", "六六");
System.out.println(student);
```



### 原子累加器

> [!Note]
>
> 原子累加器（`LongAdder`、`DoubleAdder`）是Java 8引入的高性能原子计数器，适用于**高并发写多读少**的场景，比`AtomicLong`和`AtomicDouble`具有更高的吞吐量。

---

| 类                  | 说明                 | 适用场景     |
| :------------------ | :------------------- | :----------- |
| `LongAdder`         | 高性能`long`累加器   | 计数器、统计 |
| `DoubleAdder`       | 高性能`double`累加器 | 浮点数统计   |
| `LongAccumulator`   | 支持自定义运算规则   | 更灵活的操作 |
| `DoubleAccumulator` | 支持自定义浮点运算   | 浮点运算     |

---

```java
    static void testAtomicLong() {
        AtomicLong counter = new AtomicLong();
        long start = System.currentTimeMillis();

        IntStream.range(0, 1000).parallel().forEach(i -> {
            for (int j = 0; j < 10_000; j++) {
                counter.incrementAndGet();
            }
        });

        System.out.println("AtomicLong: " + (System.currentTimeMillis() - start) + "ms");
    }

    static void testLongAdder() {
        LongAdder adder = new LongAdder();
        long start = System.currentTimeMillis();

        IntStream.range(0, 1000).parallel().forEach(i -> {
            for (int j = 0; j < 10_000; j++) {
                adder.increment();
            }
        });

        System.out.println("LongAdder: " + (System.currentTimeMillis() - start) + "ms");
    }
```

```
AtomicLong: 209ms
LongAdder: 38ms
```



> [!Tip]
>
> 累加器原理：
>
> **1. 无竞争**：直接CAS修改`base`（类似AtomicLong）
>
> **2. 有竞争**：
>
> - 初始化`Cell[]`数组（默认CPU核数）
> - 线程**哈希映射**到不同Cell，减少冲突
> - 最终结果 = `base + ∑cells[i]`



#### 伪共享

> [!Note]
>
> 伪共享是**多线程编程中的一个隐藏性能杀手**，它会导致多核CPU的缓存系统失效，严重影响并发程序的性能。理解并解决伪共享问题对编写高性能并发代码至关重要。

伪共享（False Sharing）是指：

- 多个线程**同时修改**位于**同一缓存行（Cache Line）**中的**不同变量**
- 由于CPU缓存以缓存行为单位操作，导致本无关联的变量互相影响
- 造成**不必要的缓存失效**，引发严重的性能下降

**缓存行（Cache Line）**

- CPU缓存的最小单位（通常64字节）
- 当缓存行中任一数据被修改，整个行在所有CPU核心都会失效

![image-20250411225428084](./images/image-20250411225428084.png)



**解决方案**：

**使用`@Contended`注解（JDK8+）**

```java
class Data {
    @sun.misc.Contended  // 自动填充缓存行
    volatile long x;
    
    @sun.misc.Contended
    volatile long y;
}
```

> [!Caution]
>
> **注意**：需添加JVM参数`-XX:-RestrictContended`



### Unsafe

> [!Note]
>
> Unsafe 是 Java 中的一个特殊工具类，提供了一系列**直接操作内存、绕过JVM安全机制**的底层方法。它得名"Unsafe"正是因为它的操作**不受JVM安全管理器约束**，使用不当可能导致JVM崩溃。



#### **内存操作**

- **直接内存分配/释放**

  ```java
  long address = unsafe.allocateMemory(1024); // 分配1KB堆外内存
  unsafe.setMemory(address, 1024, (byte) 0); // 内存置零
  unsafe.freeMemory(address); // 释放内存
  ```

- **内存读写**

  ```java
  unsafe.putInt(address, 123);  // 在指定地址写入int
  int value = unsafe.getInt(address); // 读取int
  ```

#### **对象操作**

- **绕过构造器创建对象**

  ```java
  MyClass obj = (MyClass) unsafe.allocateInstance(MyClass.class);
  ```

- **字段偏移量操作**

  ```java
  long offset = unsafe.objectFieldOffset(MyClass.class.getDeclaredField("value"));
  unsafe.putInt(obj, offset, 100); // 直接修改字段值
  ```

#### **线程调度**

- **线程挂起/恢复**

  ```java
  unsafe.park(false, 0); // 挂起当前线程
  unsafe.unpark(thread); // 恢复指定线程
  ```

- **CAS操作**

  ```java
  boolean success = unsafe.compareAndSwapInt(obj, offset, expect, update);
  ```

#### **数组操作**

- **获取数组元素偏移**

  ```java
  int base = unsafe.arrayBaseOffset(int[].class);
  int scale = unsafe.arrayIndexScale(int[].class);
  ```



> [!Tip]
>
> 由于安全性考虑，Unsafe 被设计为**限制获取**：
>
> **反射获取（最常用）**
>
> ```java
> Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
> theUnsafe.setAccessible(true);
> Unsafe unsafe = (Unsafe) theUnsafe.get(null);
> ```
>
> **从`TrustedFinalizer`获取（JDK内部）**
>
> ```java
> // 仅供了解，实际不推荐
> Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
> ```



## 共享模型-不可变



### 不可变类

> [!Note]
>
> 不可变类是**一旦创建后其状态就不能被修改**的类，这种设计在多线程环境下具有**线程安全、无需同步**等优势，是函数式编程和并发编程的重要基础。

---

一个严格的不可变类需要满足以下条件：

| 特征                 | 说明                   |
| :------------------- | :--------------------- |
| **所有字段final**    | 防止字段被重新赋值     |
| **类本身final**      | 防止子类破坏不可变性   |
| **无setter方法**     | 不提供修改状态的途径   |
| **防御性拷贝**       | 返回可变对象时创建副本 |
| **构造器完全初始化** | 对象创建后状态即确定   |

---

实现不可变类的关键技术:**防御性拷贝（Defensive Copy）**

当类包含**可变对象字段**时：

```java
public final class ImmutableData {
    private final Date createDate;

    public ImmutableData(Date date) {
        this.createDate = new Date(date.getTime()); // 拷贝而非直接引用
    }

    public Date getCreateDate() {
        return (Date) createDate.clone(); // 返回拷贝
    }
}
```



### 享元模式

> [!Note]
>
> 享元模式是一种**结构型设计模式**，它通过共享对象来最小化内存使用和提高性能，特别适合处理大量细粒度对象的情况。

---

| 核心概念                  | 说明                                        |
| :------------------------ | :------------------------------------------ |
| **内在状态（Intrinsic）** | 可共享的、不变的部分（如字符的Unicode值）   |
| **外在状态（Extrinsic）** | 不可共享的、变化的部分（如字符的位置/颜色） |
| **享元工厂**              | 管理共享对象的创建和复用                    |

---

#### 连接池

```java
// 模拟连接池
class Pool {
    private final int SIZE;

    private final Connection[] connections;

    private final AtomicIntegerArray states;

    public Pool(int SIZE) {
        this.SIZE = SIZE;
        connections = new Connection[SIZE];
        states = new AtomicIntegerArray(new int[SIZE]);
        for (int i = 0; i < SIZE; i++) {
            connections[i] = new MockConnection();
            states.set(i, 0);
        }
    }

    public Connection getConnection() {
        while (true) {
            for (int i = 0; i < SIZE; i++) {
                if (states.get(i) == 0 && states.compareAndSet(i, 0, 1)) {
                    log.info("获取连接: {}", i);
                    return connections[i];
                }
            }
            // 无可用连接，等待
            synchronized (this) {
                try {
                    log.info("{}-->无可用连接，等待", Thread.currentThread().getName());
                    this.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    public void releaseConnection(Connection connection) {
        for (int i = 0; i < SIZE; i++) {
            if (connections[i] == connection) {
                log.info("释放连接: {}", i);
                states.set(i, 0);
                synchronized (this) {
                    this.notifyAll();
                }
                break;
            }
        }
    }

}
```



## 共享模型-工具

### 线程池

#### 自定义线程池

![image-20250412175201187](./images/image-20250412175201187.png)

demo

```java
        ThreadPool threadPoolExecutor = ThreadPool.builder()
                .coreSize(2)
                .timeout(10, TimeUnit.SECONDS)
                .capacity(10)
                .rejectPolicy((queue, task) -> {
                    log.info("任务 {} 被拒绝", task);
                }).build();

        for (int i = 0; i < 15; i++) {
            int k = i;
            threadPoolExecutor.execute(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                log.info("执行任务 {}", k);
            });
        }
```



##### 拒绝策略（函数式接口）

```java
/**
 * 拒绝策略接口
 *
 * @param <T>
 */
@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}
```



##### 阻塞式任务队列

```java
@Slf4j
class BlockingQueue<T> {
    /**
     * 任务队列
     */
    private final Deque<T> queue = new ArrayDeque<>();

    /**
     * 队列锁
     */
    public ReentrantLock lock = new ReentrantLock();

    /**
     * 生产者条件变量
     */
    private final Condition fullWaitSet = lock.newCondition();

    /**
     * 消费者条件变量
     */
    private final Condition emptyWaitSet = lock.newCondition();

    /**
     * 队列容量
     */
    private final int capacity;

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    /**
     * 阻塞超时获取
     */
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 超时返回
                    if (nanos <= 0) {
                        return null;
                    }
                    // awaitNanos 返回剩余时间
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            fullWaitSet.signal();
            log.info("取出任务 {}", queue.peek());
            return queue.removeFirst();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞获取
     */
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            fullWaitSet.signal();
            log.info("取出任务 {}", queue.peek());
            return queue.removeFirst();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 尝试添加任务
     *
     * @param rejectPolicy 拒绝策略
     * @param task         任务
     */
    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            if (queue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞添加
     */
    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                try {
                    log.info("队列已满，等待消费者消费");
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            log.info("添加任务 {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 超时阻塞添加
     *
     * @return true 成功 false 超时失败
     */
    public boolean offer(T task, long timeout, TimeUnit unit) {
        lock.lock();
        try {
            long nanos = unit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    log.info("队列已满，等待消费者消费");
                    if (nanos <= 0) {
                        log.info("添加任务超时");
                        return false;
                    }
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            log.info("添加任务 {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }
}
```



##### 线程池

```java
@Slf4j
class ThreadPool {
    /**
     * 任务队列
     */
    private final BlockingQueue<Runnable> taskQueue;

    /**
     * 执行线程队列
     */
    private final HashSet<Worker> workers = new HashSet<>();

    /**
     * 核心线程数
     */
    private final int coreSize;

    /**
     * 超时时间
     */
    private final long timeout;

    /**
     * 超时时间单位
     */
    private final TimeUnit unit;

    /**
     * 拒绝策略
     */
    private final RejectPolicy<Runnable> rejectPolicy;

    private ThreadPool(Builder builder) {
        this.coreSize = builder.coreSize;
        this.timeout = builder.timeout;
        this.unit = builder.unit;
        this.rejectPolicy = builder.rejectPolicy;
        this.taskQueue = new BlockingQueue<>(builder.capacity);
    }

    public static Builder builder() {
        return new Builder();
    }

    /**
     * Builder构建器
     */
    public static class Builder {
        private int coreSize = 5; // 默认核心线程数
        private long timeout = 5; // 默认超时时间
        private TimeUnit unit = TimeUnit.SECONDS; // 默认时间单位
        private RejectPolicy<Runnable> rejectPolicy = (queue, task) -> {
            log.info("任务 {} 被拒绝", task);
        }; // 默认拒绝策略
        private int capacity = 100; // 默认任务队列容量

        public Builder coreSize(int coreSize) {
            this.coreSize = coreSize;
            return this;
        }

        public Builder timeout(long timeout, TimeUnit unit) {
            this.timeout = timeout;
            this.unit = unit;
            return this;
        }
        
        public Builder rejectPolicy(RejectPolicy<Runnable> rejectPolicy) {
            this.rejectPolicy = rejectPolicy;
            return this;
        }

        public Builder capacity(int capacity) {
            this.capacity = capacity;
            return this;
        }

        public ThreadPool build() {
            return new ThreadPool(this);
        }
    }

    /**
     * 执行任务
     *
     * @param task 任务
     */
    public synchronized void execute(Runnable task) {
        if (workers.size() < coreSize) {
            Worker worker = new Worker(task);
            synchronized (workers) {
                workers.add(worker);
            }
            worker.start();
        } else {
            // 队列已满，尝试拒绝策略
            taskQueue.tryPut(rejectPolicy, task);
        }
    }

    /**
     * 工作线程
     */
    class Worker extends Thread {
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @SneakyThrows
        @Override
        public void run() {
            while (task != null || (task = taskQueue.poll(timeout, unit)) != null) {
                try {
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.info("移除线程 {}", this);
                workers.remove(this);
            }
        }
    }
}
```



#### ThreadPoolExecutor

![ScheduledThreadPoolExecutor](./images/ScheduledThreadPoolExecutor.png)

##### 线程状态

`ThreadPoolExecutor` 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

---

| 状态           | 高3位 | 说明                                                         | 影响                                       |
| :------------- | :---- | :----------------------------------------------------------- | :----------------------------------------- |
| **RUNNING**    | 111   | 线程池正常运行状态，可以接收新任务并处理队列中的任务         | 新任务会被接受并执行                       |
| **SHUTDOWN**   | 000   | 关闭状态，不再接收新任务，但会处理队列中已存在的任务         | 新任务被拒绝，队列任务继续执行             |
| **STOP**       | 001   | 停止状态，不再接收新任务，也不处理队列中的任务，并中断正在执行的任务 | 新任务被拒绝，队列任务不执行，中断工作线程 |
| **TIDYING**    | 010   | 整理状态，所有任务已终止，workerCount=0，将执行terminated()钩子方法 | 过渡状态，即将变为TERMINATED               |
| **TERMINATED** | 011   | 终止状态，terminated()方法已完成                             | 线程池完全结束                             |

---



这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值

```java
    // c 为旧值， ctlOf 返回结果为新值
    ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));
    // rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
    private static int ctlOf(int rs, int wc) { return rs | wc; }
```



##### 构造方法

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler)
```

- `corePoolSize` 核心线程数目 (最多保留的线程数) 
- `maximumPoolSize` 最大线程数目 
- `keepAliveTime` 生存时间 - 针对救急线程 
- `unit` 时间单位 - 针对救急线程 
- `workQueue` 阻塞队列 
- `threadFactory` 线程工厂 - 可以为线程创建时起个好名字 
- `handler` 拒绝策略



---

**核心线程 vs 救急线程**

| 特性               | 核心线程 (Core Threads)                 | 救急线程 (救急线程/非核心线程)         |
| :----------------- | :-------------------------------------- | :------------------------------------- |
| **创建时机**       | 线程池初始化时预创建或按需创建          | 当任务数 > (核心线程数+队列容量)时创建 |
| **数量控制**       | 由`corePoolSize`参数决定                | 由`maximumPoolSize - corePoolSize`决定 |
| **存活时间**       | 默认长期存活(即使空闲)                  | 空闲超过`keepAliveTime`后被回收        |
| **回收策略**       | `allowCoreThreadTimeOut=true`时可被回收 | 总是可被回收                           |
| **任务处理优先级** | 优先使用核心线程处理任务                | 队列满且核心线程忙时才会使用           |
| **典型应用场景**   | 维持基本并发能力                        | 应对突发流量                           |

```
新任务到达时:
1. 优先使用核心线程处理
   ↓ (核心线程全忙)
2. 任务进入工作队列
   ↓ (队列已满)
3. 创建救急线程处理
   ↓ (达到maximumPoolSize)
4. 触发拒绝策略
```

---



##### 拒绝策略

| 策略名称                | 对应类                | 行为描述                                       | 适用场景                                   |
| :---------------------- | :-------------------- | :--------------------------------------------- | :----------------------------------------- |
| **AbortPolicy**         | `AbortPolicy`         | 直接抛出RejectedExecutionException异常         | 需要明确知道任务被拒绝的场景（默认策略）   |
| **CallerRunsPolicy**    | `CallerRunsPolicy`    | 由调用者线程直接执行被拒绝的任务               | 不希望丢失任务且可以接受任务执行变慢的场景 |
| **DiscardPolicy**       | `DiscardPolicy`       | 静默丢弃被拒绝的任务，不抛出异常也不执行       | 允许丢弃部分任务的场景                     |
| **DiscardOldestPolicy** | `DiscardOldestPolicy` | 丢弃队列中最旧的任务，然后尝试重新提交当前任务 | 允许丢弃旧任务，希望尽量执行新任务的场景   |



##### Executors工厂方法

###### newFixedThreadPool

```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

> [!Note]
>
> - **特点**：
>   - 固定线程数（核心线程=最大线程）
>   - 无界任务队列（`LinkedBlockingQueue`）
>   - 适合**稳定负载**场景
> - **注意事项**：
>   - 任务堆积可能导致OOM



###### newCachedThreadPool

```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

> [!note]
>
> - **特点**：
>   - 线程数无上限（`Integer.MAX_VALUE`）
>   - 空闲线程60秒后回收
>   - 适合大量**短生命周期**的异步任务
> - **风险**：
>   - 可能创建过多线程导致OOM



###### newSingleThreadExecutor

```java
    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory));
    }
```

> [!Note]
>
> - **特点**：
>   - 保证任务顺序执行（FIFO）
>   - 适用于需要**严格串行化**的场景

> [!Warning]
>
> - 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作 
> - Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 
>   - FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法 
> - Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 
>   - 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改





##### 提交任务

```java
    // 执行任务
    void execute(Runnable command);

    // 提交任务 task，用返回值 Future 获得任务执行结果
    <T> Future<T> submit(Callable<T> task);

    // 提交 tasks 中所有任务
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;

    // 提交 tasks 中所有任务，带超时时间
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)
            throws InterruptedException;

    // 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
            throws InterruptedException, ExecutionException;

    // 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException;
```

---

| 方法               | 返回值          | 是否阻塞 | 异常处理   | 适用场景      |
| :----------------- | :-------------- | :------- | :--------- | :------------ |
| `execute()`        | void            | 否       | 控制台打印 | 简单异步任务  |
| `submit(Runnable)` | Future<?>       | 否       | Future获取 | 需要任务状态  |
| `submit(Callable)` | Future<T>       | 否       | Future获取 | 需要返回结果  |
| `invokeAll()`      | List<Future<T>> | 是       | Future获取 | 批量并行任务  |
| `invokeAny()`      | T               | 是       | 直接抛出   | 获取最快结果  |
| `schedule()`       | ScheduledFuture | 否       | Future获取 | 延迟/定时任务 |

---

###### **1. `execute(Runnable)` - 基础提交**

**特点**：

- 提交`Runnable`任务
- 无返回值
- 任务异常会打印到控制台但不会抛出

**适用场景**：

- 不需要获取执行结果的简单任务
- 日志记录、异步通知等



###### **2. `submit(Runnable)` - 提交可获取状态的任务**

**特点**：

- 返回`Future<?>`对象
- 可以通过`Future.get()`判断任务是否完成
- 任务异常会被封装在`Future`中

**适用场景**：

- 需要知道任务是否执行完成
- 不需要返回结果但需要异常处理



###### **3. `submit(Callable<T>)` - 提交有返回值的任务**

**特点**：

- 提交`Callable`任务
- 返回`Future<T>`可获取计算结果
- 任务异常可通过`Future.get()`捕获

**适用场景**：

- 需要获取异步计算结果
- 并行计算、远程调用等



###### **4. `invokeAll()` - 批量提交并等待所有任务完成**

**特点**：

- 提交`Callable`任务集合
- 返回`List<Future<T>>`
- 阻塞直到所有任务完成

**适用场景**：

- 并行处理多个任务并收集所有结果
- 分布式计算聚合



###### **5. `invokeAny()` - 提交多个任务获取首个完成结果**

**特点**：

- 提交`Callable`任务集合
- 返回首个完成的任务结果
- 其他未完成任务会被取消

**适用场景**：

- 多个服务提供相同功能时获取最快响应
- 竞速查询（如多数据源查询）



##### 关闭线程池

---

| 方法                     | 说明     | 行为特点                                       |
| :----------------------- | :------- | :--------------------------------------------- |
| **`shutdown()`**         | 平缓关闭 | 停止接收新任务，已提交任务继续执行             |
| **`shutdownNow()`**      | 立即关闭 | 尝试停止所有正在执行的任务，返回未执行任务列表 |
| **`awaitTermination()`** | 等待终止 | 主线程阻塞直到所有任务完成或超时               |

---





#### 工作线程模式

##### 定义

让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。

工作线程模式（也称为**线程池模式**）是一种并发设计模式，它通过维护一组预先创建的线程来执行任务，避免了频繁创建和销毁线程的开销，是Java并发编程的核心模式之一。



##### 饥饿

线程饥饿是指**某些任务因长期无法获取执行资源而延迟执行**的现象

固定线程池大小容易发生

- 嵌套提交任务
- 长任务阻塞短任务
- 不公平的任务调度



示例：

```java
ExecutorService executor = Executors.newFixedThreadPool(1); // 单线程池

executor.execute(() -> {
    Future<String> future = executor.submit(() -> "result"); // 嵌套提交任务
    try {
        future.get(); // 阻塞等待
    } catch (Exception e) {
        e.printStackTrace();
    }
});
```

> [!Caution]
>
> 避免嵌套提交，不同的任务使用不同线程池
>
> ```java
> // 使用不同的线程池
> ExecutorService executor1 = Executors.newFixedThreadPool(1);
> ExecutorService executor2 = Executors.newFixedThreadPool(1);
> 
> executor1.execute(() -> {
>     Future<String> future = executor2.submit(() -> "result");
>     future.get(); // 不会饥饿
> });
> ```





##### 合适的线程池大小

**CPU密集型任务**

- **特点**：大量计算，很少I/O等待（如数学运算、视频编码）

- **公式**：

  ```
  线程数 = CPU核心数 + 1
  ```

  （+1是为了防止线程意外暂停时能利用空闲CPU）



**I/O密集型任务**

- **特点**：大量等待时间（如数据库查询、HTTP请求）

- **公式**：

  ```
  线程数 = CPU核心数 × (1 + 平均等待时间/平均计算时间)
  ```

  经验值通常为：

  ```
  线程数 = CPU核心数 × 2 ~ 5
  ```



#### 任务调度线程池

> [!Note]
>
> 在『任务调度线程池』功能加入之前，可以使用 `java.util.Timer` 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。



```java
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);

        // 延时执行
        log.info("task start");
        pool.schedule(() -> {
            log.info("running...");
        }, 1000, TimeUnit.MILLISECONDS);

        // 定时执行
        pool.scheduleAtFixedRate(() -> {
            log.info("running...");
        },0, 1, TimeUnit.SECONDS);
        
        // 任务结束后才开始计算延迟时间
        pool.scheduleWithFixedDelay(() -> {
            log.info("running...");
        },0, 1, TimeUnit.SECONDS);
```



#### 线程池异常处理

> [!Caution]
>
> 线程池中的任务默认不处理异常，需要自己处理

- **直接在任务内部 try-catch**

```java
executor.scheduleAtFixedRate(() -> {
    try {
        // 业务代码
        log.info("Running...");
    } catch (Exception e) {
        log.error("Task failed", e); // 明确捕获并记录异常
    }
}, 0, 1, TimeUnit.SECONDS);

```

- **通过 `Future` 获取异常（适用于一次性任务）**

```java
Future<?> future = executor.submit(() -> {
    // 可能抛出异常的任务
});
try {
    future.get(); // 会抛出 ExecutionException（包装实际异常）
} catch (ExecutionException e) {
    Throwable realException = e.getCause(); // 获取原始异常
    log.error("Task failed", realException);
}
```

- **自定义线程池的 `UncaughtExceptionHandler`**

```java
ThreadFactory factory = r -> {
    Thread thread = new Thread(r);
    thread.setUncaughtExceptionHandler((t, e) -> {
        log.error("Thread {} crashed", t.getName(), e);
    });
    return thread;
};

ExecutorService executor = Executors.newScheduledThreadPool(2, factory);

```



#### Tomcat线程池

![image-20250414161537812](./images/image-20250414161537812.png)

- LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的  Semaphore 
- Acceptor 只负责【接收新的 socket 连接】 
- Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理 
- Executor 线程池中的工作线程最终负责【处理请求】



---

Connector 配置

| 配置项              | 默认值 | 说明                                   |
| ------------------- | ------ | -------------------------------------- |
| acceptorThreadCount | 1      | acceptor 线程数量                      |
| pollerThreadCount   | 1      | poller 线程数量                        |
| minSpareThreads     | 10     | 核心线程数，即 corePoolSize            |
| maxThreads          | 200    | 最大线程数，即 maximumPoolSize         |
| executor            | -      | Executor 名称，用来引用下面的 Executor |

---

 Executor 线程配置

| **配置项**              | **默认值**        | **说明**                                  |
| ----------------------- | ----------------- | ----------------------------------------- |
| threadPriority          | 5                 | 线程优先级                                |
| daemon                  | true              | 是否守护线程                              |
| minSpareThreads         | 25                | 核心线程数，即 corePoolSize               |
| maxThreads              | 200               | 最大线程数，即 maximumPoolSize            |
| maxIdleTime             | 60000             | 线程生存时间，单位是毫秒，默认值即 1 分钟 |
| maxQueueSize            | Integer.MAX_VALUE | 队列长度                                  |
| prestartminSpareThreads | false             | 核心线程是否在服务器启动时启动            |

---



#### ForkJoin线程池

Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种**分治**思想，适用于能够进行**任务拆分的 cpu 密集型运算** 

所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解 

Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 

Fork/Join 默认会创建与 cpu 核心数大小相同的线程池

```java
        // 创建ForkJoinPool线程池
        ForkJoinPool pool = new ForkJoinPool();
        // 提交AddTask任务到线程池，n初始值为10
        ForkJoinTask<Integer> submit = pool.submit(new AddTask(10));
        // 获取任务执行结果并打印
        log.debug("submit() {}", submit.get());


@Slf4j
// AddTask继承RecursiveTask<Integer>，表示这是一个可以递归分解的任务，返回Integer类型结果
class AddTask extends RecursiveTask<Integer> {
    int n;  // 任务处理的数值

    public AddTask(int n) {
        this.n = n;
    }

    @Override
    public String toString() {
        return "{" + n + '}';  // 方便打印任务信息
    }

    @Override
    protected Integer compute() {
        // 基准条件：如果n已经为1，直接返回1
        if (n == 1) {
            log.debug("join() {}", n);
            return n;
        }
        // 递归条件：将任务拆分为更小的子任务
        AddTask t1 = new AddTask(n - 1);  // 创建处理n-1的子任务
        t1.fork();  // 异步执行子任务
        log.debug("fork() {} + {}", n, t1);
        // 合并子任务的结果：当前n的值加上子任务的结果
        int result = n + t1.join();  // 等待子任务完成并获取结果
        log.debug("join() {} + {} = {}", n, t1, result);
        return result;
    }
}
```



### JUC

#### AQS原理

全称 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架

特点： 

- 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 
  - getState - 获取 state 状态 
  - setState - 设置 state 状态 
  - compareAndSetState - cas 机制设置 state 状态 
  - 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 
- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 
- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet



子类主要实现如下方法（默认抛出 UnsupportedOperationException） 

- `tryAcquire`
- `tryRelease` 
- `tryAcquireShared` 
- `tryReleaseShared`
- `isHeldExclusively`



自定义锁demo

```java
class MyLock implements Lock {

    // 同步器类
    static class MySync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(arg, arg + 1)) {
                // 获取锁成功，设置独占线程
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            // 释放锁，将状态设置为0，并将独占线程设置为null
            setExclusiveOwnerThread(null);
            setState(arg - 1); // volatile 变量，保证线程间可见性
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }

    private final MySync sync = new MySync();

    private volatile int state = 0;


    // 加锁
    @Override
    public void lock() {
        sync.acquire(state);
    }

    // 可打断加锁
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(state);
    }

    @Override
    public boolean tryLock() {
        return sync.tryAcquire(state);
    }

    // 带超时加锁
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(state, unit.toNanos(time));
    }

    // 解锁
    @Override
    public void unlock() {
        sync.release(state);
    }

    // 条件变量
    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
}
```



#### 读写锁

##### ReentrantReadWriteLock

当读操作远远高于写操作时，这时候使用读写锁 让 **读-读** 可以并发，提高性能，这种锁机制适用于读多写少的场景，可以提高并发性能。



```java
class DataContainer {
    Object data = new Object();
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    private final ReentrantReadWriteLock.ReadLock readLock = lock.readLock();
    private final ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    public Object read() throws InterruptedException {
        log.info("尝试获取读取锁");
        readLock.lock();
        try {
            log.info("获取读锁成功");
            Thread.sleep(1000);
            return data;
        } finally {
            log.info("释放读锁");
            readLock.unlock();
        }
    }

    public void write(Object data) {
        log.info("尝试获取写锁");
        writeLock.lock();
        try {
            log.info("获取写锁成功");
            this.data = data;
        } finally {
            log.info("释放写锁");
            writeLock.unlock();
        }
    }
}
```

> [!Note]
>
> - 读锁不支持条件变量
> - 重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待
> - 重入时降级支持：即持有写锁的情况下去获取读锁



##### StampedLock

> [!Note]
>
> **应用场景**
>
> - 高并发读多写少的场景。
>
> - 对性能要求较高的场景。
> - 需要乐观读锁的场景。



它是一种改进的读写锁，提供了更高的性能和更灵活的功能，尤其是在读多写少的场景下，性能优于 `ReentrantReadWriteLock`。



```java
public class StampedLockExample {
    private final StampedLock stampedLock = new StampedLock();
    private int sharedData = 0;

    public void writeData(int data) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            sharedData = data;
            System.out.println("Write data: " + sharedData);
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
}
    
    
public void readData() {
    long stamp = stampedLock.readLock(); // 获取悲观读锁
    try {
        System.out.println("Read data: " + sharedData);
    } finally {
        stampedLock.unlockRead(stamp); // 释放读锁
    }
}
    
public void optimisticReadData() {
    long stamp = stampedLock.tryOptimisticRead(); // 尝试获取乐观读锁
    int data = sharedData; // 读取数据
    if (!stampedLock.validate(stamp)) { // 验证乐观读锁是否有效
        stamp = stampedLock.readLock(); // 如果无效，降级为悲观读锁
        try {
            data = sharedData; // 再次读取数据
        } finally {
            stampedLock.unlockRead(stamp); // 释放悲观读锁
        }
    }
    System.out.println("Optimistic read data: " + data);
}
```



**注意事项**

1. **不可重入**：`StampedLock` 是不可重入的，同一个线程如果多次获取锁，可能会导致死锁。
2. **锁的释放**：必须通过 `unlockRead` 或 `unlockWrite` 方法释放锁，否则会导致死锁。
3. **乐观读锁的验证**：使用乐观读锁时，必须通过 `validate` 方法验证锁的有效性，否则可能导致数据不一致。
4. **锁的转换**：锁的转换需要小心处理，避免死锁或资源泄漏。





#### Semaphore

`Semaphore`（信号量）是 Java 并发包 (`java.util.concurrent`) 中的一个重要工具类，用于**控制对共享资源的并发访问数量**。它基于经典的 Dijkstra 信号量概念实现，是一种计数信号量。



核心方法

```java
Semaphore(int permits)  // 创建非公平信号量
Semaphore(int permits, boolean fair)  // 创建公平/非公平信号量

void acquire()  // 获取1个许可证，阻塞直到获取成功
void acquire(int permits)  // 获取指定数量的许可证
void release()  // 释放1个许可证
void release(int permits)  // 释放指定数量的许可证

boolean tryAcquire()  // 尝试获取1个许可证，立即返回结果
boolean tryAcquire(long timeout, TimeUnit unit)  // 超时尝试获取
boolean tryAcquire(int permits)  // 尝试获取多个许可证
int availablePermits()  // 返回当前可用许可证数量
void drainPermits()  // 获取并返回所有立即可用的许可证
```



示例

```java
        // 创建一个信号量，初始值为3
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    log.info("成功获得信号量");
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                } finally {
                    semaphore.release();
                }
            }).start();
        }
```



**应用场景**

1. 资源池管理（如数据库连接池）
2. 限流控制（限制并发请求数），仅限单机模式



**原理**：计数器限制资源访问数

![image-20250418161221923](./images/image-20250418161221923.png)





#### CountDownLatch

`CountDownLatch` 是 Java 并发编程中简单高效的同步工具，特别适合"主线程等待多个子线程完成"的场景。



**核心方法**

```java
CountDownLatch(int count)  // 初始化计数器值

void await()  // 阻塞当前线程直到计数器归零
boolean await(long timeout, TimeUnit unit)  // 带超时的等待
void countDown()  // 计数器减1
long getCount()  // 获取当前计数值
```



**注意事项**

- **不可重置**：计数器归零后无法重复使用
- **等待机制**：支持多个线程等待同一个事件
- **计数递减**：只能减少计数，不能增加
- **线程协作**：协调多个线程的执行顺序



主线程等待其他线程结束

```java
        CountDownLatch latch = new CountDownLatch(10);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " is running");
                try {
                    latch.countDown();
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        latch.await();
```

> [!Tip]
>
> 同样可以使用join()来实现，不过CountDownLatch是封装过的API，使用更方便



#### CyclicBarrier

- **循环屏障**：可重复使用的同步屏障
- **核心思想**：一组线程相互等待，直到所有线程都到达屏障点
- **可重用性**：与 `CountDownLatch` 不同，`CyclicBarrier` 可重复使用（屏障被触发后自动重置，可再次使用）
- **可选回调**：可以设置屏障触发时的回调动作（由最后一个到达屏障的线程执行）



**核心方法**

```java
CyclicBarrier(int parties)  // 创建屏障，指定参与线程数
CyclicBarrier(int parties, Runnable barrierAction)  // 创建带回调的屏障
    
int await()  // 等待所有线程到达屏障
int await(long timeout, TimeUnit unit)  // 带超时的等待
void reset()  // 重置屏障
int getParties()  // 获取参与线程数
int getNumberWaiting()  // 获取当前等待的线程数
boolean isBroken()  // 检查屏障是否被破坏
```



示例

```java
public class CyclicBarrierDemo {
    private static final int THREAD_COUNT = 3;
    private static final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT, 
        () -> System.out.println("所有线程已到达屏障，继续执行"));

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        
        for (int i = 0; i < THREAD_COUNT; i++) {
            final int threadNum = i;
            executor.execute(() -> {
                try {
                    System.out.println("线程" + threadNum + "开始工作");
                    Thread.sleep((long) (Math.random() * 2000)); // 模拟工作耗时
                    System.out.println("线程" + threadNum + "到达屏障，等待其他线程");
                    barrier.await();
                    System.out.println("线程" + threadNum + "继续执行");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
        executor.shutdown();
    }
}
```



#### 线程安全集合类

![image-20250419152902996](./images/image-20250419152902996.png)

线程安全集合类可以分为三大类： 

- 遗留的线程安全集合如  `Hashtable` ， `Vector`
- 使用 Collections 装饰的线程安全集合:
  - `Collections.synchronizedCollection `
  - `Collections.synchronizedList `
  - `Collections.synchronizedMap `
  - `Collections.synchronizedSet `
  - `Collections.synchronizedNavigableMap `
  - `Collections.synchronizedNavigableSet`
  - `Collections.synchronizedSortedMap `
  - `Collections.synchronizedSortedSet`
- `java.util.concurrent.*`



`java.util.concurrent.*` 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent

- Blocking 大部分实现基于锁，并提供用来阻塞的方法 
- CopyOnWrite 之类容器修改开销相对较重 
- Concurrent 类型的容器
  - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 
  - 弱一致性
    - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的
    - 求大小弱一致性，size 操作未必是 100% 准确 
    - 读取弱一致性

> [!Tip]
>
> **快速失败**
>
> 遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出 `ConcurrentModificationException`，不再继续遍历



#### ConcurrentHashMap

线程安全的哈希表实现，专为高并发场景设计，比 `Hashtable` 和 `Collections.synchronizedMap()` 有更好的并发性能。



**基本操作**

```java
V put(K key, V value)  // 插入键值对
V get(Object key)      // 获取值
V remove(Object key)   // 删除键值对
boolean containsKey(Object key) // 检查键是否存在
    
V putIfAbsent(K key, V value)  // 不存在则插入
boolean remove(Object key, Object value) // 匹配则删除
V replace(K key, V value)      // 替换值
    
void forEach(BiConsumer<? super K, ? super V> action) // 并行遍历
V reduce(long parallelismThreshold, BiFunction<? super K, ? super V, ? extends U> transformer, BiFunction<? super U, ? super U, ? extends U> reducer) // MapReduce
```



##### 并发死链

在 JDK 1.7 版本的 `HashMap` 实现中，存在一个可能导致并发死链(dead chain)的问题，这是在特定并发操作场景下可能发生的严重问题。



**触发条件**

**多线程并发扩容时可能形成环形链表**

JDK 1.7 的扩容采用**头插法**迁移数据

```java
void transfer(Entry[] newTable) {
    for (Entry<K,V> e : table) {
        while (e != null) {
            Entry<K,V> next = e.next;  // 记录下一个节点
            int i = indexFor(e.hash, newTable.length);
            e.next = newTable[i];     // 头插法：将当前节点指向桶头
            newTable[i] = e;          // 更新桶头为当前节点
            e = next;                 // 处理下一个节点
        }
    }
}
```

假设初始链表：`A → B → null`
两个线程并发扩容时可能产生以下时序：

|   操作步骤    |                       线程1（被挂起）                        |                      线程2（完整执行）                       |         链表状态变化          |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :---------------------------: |
|   开始扩容    |                   读取 `e = A`, `next = B`                   |                                                              |         A → B → null          |
|   线程1挂起   |               暂停执行（持有 `e=A`, `next=B`）               |                           开始扩容                           |                               |
|   线程2执行   |                                                              | 完整执行扩容： ① 迁移A：`newTable[i] = A → null` ② 迁移B：`newTable[i] = B → A → null` | 线程2的新链表：`B → A → null` |
|   线程1恢复   |            继续执行（仍用旧指针 `e=A`, `next=B`）            |                                                              |                               |
| 线程1错误操作 | ① 将A插入新桶：`A.next = newTable[i]`（此时`newTable[i]=B`） ② 结果：`A → B → A → B...` |                                                              |  **形成环形链表：B → A → B**  |



##### 重要属性和内部类

```java
        // 默认为 0
        // 当初始化时, 为 -1
        // 当扩容时, 为 -(1 + 扩容线程数)
        // 当初始化或扩容完成后，为 下一次的扩容的阈值大小
        private transient volatile int sizeCtl;

        // 整个 ConcurrentHashMap 就是一个 Node[]
        static class Node<K,V> implements Map.Entry<K,V> {}

        // hash 表
        transient volatile Node<K,V>[] table;

        // 扩容时的 新 hash 表
        private transient volatile Node<K,V>[] nextTable;

        // 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点
        static final class ForwardingNode<K,V> extends Node<K,V> {}

        // 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node
        static final class ReservationNode<K,V> extends Node<K,V> {}

        // 作为 treebin 的头节点, 存储 root 和 first
        static final class TreeBin<K,V> extends Node<K,V> {}

        // 作为 treebin 的节点, 存储 parent, left, right
        static final class TreeNode<K,V> extends Node<K,V> {}
```



#### LinkedBlockingQueue

**线程安全、基于链表实现的有界/无界阻塞队列**。它采用 **FIFO（先进先出）** 策略，适用于生产者-消费者模型，支持高并发操作。

---

|     特性     | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
| **数据结构** | 单向链表（`Node` 节点存储数据）                              |
| **线程安全** | 使用 **两把锁（ReentrantLock）** 分别控制入队和出队，降低竞争 |
| **阻塞机制** | 队列满时，`put()` 阻塞；队列空时，`take()` 阻塞              |
|   **容量**   | 默认无界（`Integer.MAX_VALUE`），可指定有界容量              |
|  **公平性**  | 锁默认非公平（可配置为公平锁）                               |
|  **迭代器**  | 弱一致性（`iterator()` 遍历时可能反映部分修改）              |

---



**入队方法**

|                   方法                    |                        说明                        | 阻塞/非阻塞  |  返回值   |
| :---------------------------------------: | :------------------------------------------------: | :----------: | :-------: |
|                `put(E e)`                 |               插入元素，队列满时阻塞               |   **阻塞**   |  `void`   |
|               `offer(E e)`                |           插入元素，队列满时返回 `false`           |    非阻塞    | `boolean` |
| `offer(E e, long timeout, TimeUnit unit)` |                插入元素，超时后放弃                | **限时阻塞** | `boolean` |
|                `add(E e)`                 | 插入元素，队列满时抛异常（继承自 `AbstractQueue`） |    非阻塞    | `boolean` |



**出队方法**

|                方法                 |                          说明                          | 阻塞/非阻塞  | 返回值 |
| :---------------------------------: | :----------------------------------------------------: | :----------: | :----: |
|              `take()`               |               移除队首元素，队列空时阻塞               |   **阻塞**   |  `E`   |
|              `poll()`               |           移除队首元素，队列空时返回 `null`            |    非阻塞    |  `E`   |
| `poll(long timeout, TimeUnit unit)` |                移除队首元素，超时后放弃                | **限时阻塞** |  `E`   |
|             `remove()`              | 移除队首元素，队列空时抛异常（继承自 `AbstractQueue`） |    非阻塞    |  `E`   |



**LinkedBlockingQueue 与 ArrayBlockingQueue 的比较**

- Linked 支持有界，Array 强制有界 
- Linked 实现是链表，Array 实现是数组 
- Linked 是懒惰的，而 Array 需要提前初始化 Node 数组 
- Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的 
- Linked 两把锁，Array 一把锁



|     特性     | `ConcurrentLinkedQueue` |    `LinkedBlockingQueue`     |
| :----------: | :---------------------: | :--------------------------: |
|  **锁机制**  |       无锁（CAS）       |   两把锁（入队、出队分离）   |
| **阻塞支持** |         非阻塞          | 支持阻塞（`put()`/`take()`） |
|   **容量**   |          无界           |       可配置有界/无界        |
|   **性能**   |      更高（无锁）       |        较低（锁竞争）        |
| **适用场景** |   高并发、非阻塞需求    |      需要阻塞控制的场景      |


---

**下一节**：[进程与线程](并发编程-进程与线程.md)