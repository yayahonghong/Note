# 并发编程三要素

---
原子性、可见性、有序性

---

## 原子性

原子性是指一个操作不可被中断，要么全部执行成功，要么全部不执行，不会被线程调度机制打断

通过**锁**机制可以保证原子性。

<br>

---

## 可见性

退不出的循环

```java
    static boolean run = true;

    public static void main(String[] args) {

        new Thread(() -> {
            while (run) {
                // do something
            }
        }).start();

        log.info("stop thread");
        run = false;
    }
```

以上线程并不会在`run`的值改变后退出


原因如下：

![image-20250409150006920](./images/image-20250409150006920.png)

1. **JMM的可见性问题**：
    - 在Java内存模型中，每个线程有自己的工作内存(缓存)
    - `run`变量是普通变量(非volatile)，修改可能不会立即对其他线程可见
    - 主线程修改`run=false`后，子线程可能仍然读取的是自己工作内存中的旧值`true`
2. **编译器/JIT优化**：
    - JIT编译器可能会将`while(run)`优化为`while(true)`，因为循环体内没有操作
    - 这种优化称为"循环提升"(Loop Hoisting)



**解决方案**

1.使用volatile关键字(推荐)

```java
static volatile boolean run = true;
```

`volatile`保证：

- 可见性：修改立即对其他线程可见
- 有序性：禁止指令重排序

<br>

2.使用synchronized同步

```java
static boolean run = true;
static final Object lock = new Object();

// 写操作
synchronized(lock) {
    run = false;
}

// 读操作
synchronized(lock) {
    while(run) { ... }
}
```
synchronized保证同步块内对变量的修改对其他线程可见

<br>

### 两阶段终止模式

可以使用`volatile`实现该模式

<br>

### Balking模式

Balking模式是一种**多线程设计模式**，用于在对象处于不适当状态时立即放弃当前操作，而不是等待状态变为可用状态。



典型场景

1. 文件自动保存功能（如果已经保存过则不再重复保存）
2. 服务初始化（只初始化一次）
3. 网络请求取消（如果已经开始处理则不接受取消）
4. 线程启动检查（如果线程已在运行则不重复启动）



```java
class VolatileBalking {
    private volatile boolean initialized = false;
    
    public void init() {
        if (initialized) {
            return;
        }
        synchronized (this) {
            if (initialized) { // 双重检查
                return;
            }
            doInit();
            initialized = true;
        }
    }
    
    private void doInit() {
        // 初始化逻辑
    }
}
```



例：线程安全的单例模式

```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {                  // 第一次检查：Balking，直接返回避免同步，优化性能
            synchronized (Singleton.class) {      // 同步
                if (instance == null) {          // 第二次检查：线程安全
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

<br>

---

## 有序性

**指令重排**：在**不改变单线程程序语义**的前提下，编译器、运行时或处理器可能会改变代码的执行顺序

> 指令重排，这个现象需要通过**大量**测试才能复现（ java 并发压测工具 jcstress）

 

示例

```java
    boolean ready = false;
    int num = 0;
    // 线程1 执行此方法
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        }
        else {
            r.r1 = 1;
        }
    }
    // 线程2 执行此方法
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
```

> [!Tip]
>
> 以上代码，`r.r1`的值可能是1，4，**0**
>
> 其中0是指令重排序的结果



- 禁止重排序：
  - 在volatile写之前的所有操作不会被重排序到写之后
  - 在volatile读之后的所有操作不会被重排序到读之前



> [!Caution]
>
> `synchronized` 是不能阻止指令重排的



#### volatile

内存屏障是处理器提供的一组特殊指令，用于控制指令执行顺序和内存可见性，在多线程编程中至关重要。读屏障和写屏障是两种基本的内存屏障类型。

##### 读屏障

- 确保屏障后的**读操作**不会重排序到屏障前
- 强制从主内存（而非缓存）重新加载数据

##### 写屏障

- 确保屏障前的**写操作**不会重排序到屏障后
- 强制将写缓冲区内容刷入主内存



#####  double-checked locking 问题

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) { // t2
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

字节码

```java
0: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull     37
6: ldc           #3                  // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter
11: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull     27
17: new           #3                  // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4                  // Method "<init>":()V
24: putstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto          37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
```

其中 

17 表示创建对象，将对象引用入栈  // new Singleton 

20 表示复制一份对象引用  // 引用地址 

21 表示利用一个对象引用，调用构造方法  

24 表示利用一个对象引用，赋值给 static INSTANCE 

也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：

![image-20250409164312112](./images/image-20250409164312112.png)

关键在于 

0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例 

**对 INSTANCE 使用 volatile 修饰即可**，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效



读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence））

- 可见性
  - 写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中 
  - 而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据 
- 有序性
  - 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 
  - 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

- 更底层是读写变量时使用 lock 指令来实现多核 CPU 之间的可见性与有序性



#### happens-before

happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛 开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见

1. 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见

```java
        static int x;
        static Object m = new Object();
        new Thread(() -> {
            synchronized (m) {
                x = 10;
            }
        }, "t1").start();
        new Thread(() -> {
            synchronized (m) {
                System.out.println(x);
            }
        }, "t2").start();
```

2. 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

```java
        volatile static int x;
        new Thread(()->{
            x = 10;
        },"t1").start();
        new Thread(()->{
            System.out.println(x);
        },"t2").start();
```

3. 线程 start 前对变量的写，对该线程开始后对该变量的读可见

```java
        static int x;
        x = 10;
        new Thread(()->{
            System.out.println(x);
        },"t2").start();
```

4. 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）

```java
        static int x;
        Thread t1 = new Thread(()->{
            x = 10;
        },"t1");
        t1.start();
        t1.join();
        System.out.println(x);
```

5. 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）

```java
        static int x;

        Thread t2 = new Thread(()->{
            while(true) {
                if(Thread.currentThread().isInterrupted()) {
                    System.out.println(x);
                    break;
                }
            }
        },"t2");
        t2.start();
        new Thread(()->{
            sleep(1);
            x = 10;
            t2.interrupt();
        },"t1").start();

        while(!t2.isInterrupted()) {
            Thread.yield();
        }
        System.out.println(x);
```

6. 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见
7. 具有传递性，如果  x hb-> y 并且  y hb-> z 那么有  x hb-> z ，配合 volatile 的防指令重排

```java
        volatile static int x;
        static int y;
        new Thread(()->{
            y = 10;
            x = 20;
        },"t1").start();
        new Thread(()->{
            // x=20 对 t2 可见, 同时 y=10 也对 t2 可见
            System.out.println(x);
        },"t2").start();
```



### 单例模式实现

> [!Tip]
>
> 以下实现均为线程安全

- 饿汉式

```java
public final class Singleton {
    private Singleton(){}
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```



- 双重检查

```java
public final class Singleton implements Serializable {
    private Singleton() {}
    private volatile static Singleton INSTANCE = null;
    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            // 可能有多个线程到达该分支
            synchronized (Singleton.class) {
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
    
    // 防止反序列化重新创建对象
    public Object readResolve() {
        return INSTANCE;
    }
}
```



- 枚举

```java
enum Singleton {
    INSTANCE;
}
```



- 静态内部类

```java
final class Singleton {
    // 私有构造函数，防止外部实例化
    private Singleton() {
        
    }
    
    // 静态内部类，用于延迟初始化单例实例
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    // 提供全局访问点，返回单例实例
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```


