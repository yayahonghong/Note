
## 定义及实现

不可变类是**一旦创建后其状态就不能被修改**的类，这种设计在多线程环境下具有**线程安全、无需同步**等优势，是函数式编程和并发编程的重要基础。

---

一个严格的不可变类需要满足以下条件：

| 特征                 | 说明                   |
| :------------------- | :--------------------- |
| **所有字段final**    | 防止字段被重新赋值     |
| **类本身final**      | 防止子类破坏不可变性   |
| **无setter方法**     | 不提供修改状态的途径   |
| **防御性拷贝**       | 返回可变对象时创建副本 |
| **构造器完全初始化** | 对象创建后状态即确定   |

---

实现不可变类的关键技术:**防御性拷贝（Defensive Copy）**

当类包含**可变对象字段**时：

```java
public final class ImmutableData {
    private final Date createDate;

    public ImmutableData(Date date) {
        this.createDate = new Date(date.getTime()); // 拷贝而非直接引用
    }

    public Date getCreateDate() {
        return (Date) createDate.clone(); // 返回拷贝
    }
}
```

<br>

---

## 享元模式

享元模式是一种**结构型设计模式**，它通过共享对象来最小化内存使用和提高性能，特别适合处理大量细粒度对象的情况。

---

| 核心概念                  | 说明                                        |
| :------------------------ | :------------------------------------------ |
| **内在状态（Intrinsic）** | 可共享的、不变的部分（如字符的Unicode值）   |
| **外在状态（Extrinsic）** | 不可共享的、变化的部分（如字符的位置/颜色） |
| **享元工厂**              | 管理共享对象的创建和复用                    |

---

<br>

## 连接池

连接池是享元模式的经典应用，通过复用数据库连接对象，减少频繁创建和销毁连接的开销。

<br>

示例代码：

```java
class Pool {
    private final int SIZE;

    private final Connection[] connections;

    private final AtomicIntegerArray states;

    public Pool(int SIZE) {
        this.SIZE = SIZE;
        connections = new Connection[SIZE];
        states = new AtomicIntegerArray(new int[SIZE]);
        for (int i = 0; i < SIZE; i++) {
            connections[i] = new MockConnection();
            states.set(i, 0);
        }
    }

    public Connection getConnection() {
        while (true) {
            for (int i = 0; i < SIZE; i++) {
                if (states.get(i) == 0 && states.compareAndSet(i, 0, 1)) {
                    log.info("获取连接: {}", i);
                    return connections[i];
                }
            }
            // 无可用连接，等待
            synchronized (this) {
                try {
                    log.info("{}-->无可用连接，等待", Thread.currentThread().getName());
                    this.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    public void releaseConnection(Connection connection) {
        for (int i = 0; i < SIZE; i++) {
            if (connections[i] == connection) {
                log.info("释放连接: {}", i);

                // 此时无需加锁，因为只有持有该连接的线程才能修改状态
                states.set(i, 0);
                
                synchronized (this) {
                    this.notifyAll();
                }
                break;
            }
        }
    }
}
```


---

**上一节**：[乐观锁](乐观锁.md)

**下一节**：[并发工具](并发工具.md)
